<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JSON Quiz Viewer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f9f9f9;
      margin: 0;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .topic {
      background-color: #eee;
      padding: 10px;
      margin-top: 20px;
      font-weight: bold;
      font-size: 18px;
      position: sticky;
      top: 0;
    }

    .question {
      margin: 10px 0 20px 0;
      padding: 10px;
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 5px;
    }

    .question-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .keywords {
      margin-top: 10px;
    }

    .keyword {
      display: inline-block;
      margin-right: 10px;
    }
    .scroll-percent {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 16px;
      font-weight: bold;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 4px 8px;
      border-radius: 4px;
      z-index: 100;
    }

  </style>
</head>
<body>

<!-- Texte de progression -->
<div id="scrollPercent" class="scroll-percent">0%</div>


<div class="container">
  <h1>JSON Quiz Viewer</h1>

  <input type="file" id="jsonFileInput" accept=".json">
  <div id="content"></div>
</div>
<script type="application/javascript">
  let defaultData = [
    {
      "topic": "Java",
      "questions": [
        {
          "question": "Quelle est la différence entre `==` et `.equals()` en Java ?",
          "textResponse": "En Java, `==` compare les références des objets en mémoire, tandis que `.equals()` compare la valeur logique ou le contenu. Pour les types primitifs, `==` compare directement les valeurs. Pour les objets, il est souvent nécessaire de redéfinir la méthode `.equals()` pour obtenir un comportement basé sur la valeur.",
          "keyWords": [
            "références",
            "mémoire",
            "valeur logique",
            "contenu",
            "types primitifs",
            "redéfinir equals"
          ]
        },
        {
          "question": "Qu'est-ce que le polymorphisme en Java et pourquoi est-il important ?",
          "textResponse": "Le polymorphisme est la capacité d'un objet à prendre plusieurs formes en fonction du contexte. En Java, il se manifeste via la surcharge de méthodes (polymorphisme statique) et la redéfinition de méthodes (polymorphisme dynamique). Il permet la flexibilité, l'extensibilité et favorise l'utilisation de l'héritage et des interfaces.",
          "keyWords": [
            "polymorphisme",
            "surcharge",
            "polymorphisme statique",
            "redéfinition",
            "polymorphisme dynamique",
            "flexibilité",
            "extensibilité",
            "héritage",
            "interfaces"
          ]
        },
        {
          "question": "Quelle est la différence entre une `abstract class` et une `interface` en Java ?",
          "textResponse": "Une `abstract class` peut contenir des méthodes implémentées et des variables d'état, tandis qu'une `interface` ne définissait initialement que des signatures de méthodes. Depuis Java 8, une interface peut contenir des méthodes par défaut et statiques. Une classe ne peut hériter que d'une seule `abstract class`, mais elle peut implémenter plusieurs interfaces, ce qui favorise l'abstraction multiple.",
          "keyWords": [
            "abstract class",
            "méthodes implémentées",
            "variables d'état",
            "interface",
            "signatures de méthodes",
            "Java 8",
            "méthodes par défaut",
            "méthodes statiques",
            "abstraction multiple"
          ]
        },
        {
          "question": "Qu'est-ce que le concept de thread-safe en Java ?",
          "textResponse": "Un code est dit thread-safe s'il fonctionne correctement lorsqu'il est exécuté par plusieurs threads simultanément. Cela implique de contrôler les accès concurrents aux ressources partagées via la synchronisation, l'utilisation de verrous comme `ReentrantLock` ou de collections concurrentes comme `ConcurrentHashMap`. La thread-safety évite les conditions de course et les incohérences de données.",
          "keyWords": [
            "thread-safe",
            "threads",
            "ressources partagées",
            "synchronisation",
            "verrous",
            "ReentrantLock",
            "ConcurrentHashMap",
            "conditions de course",
            "incohérences de données"
          ]
        },
        {
          "question": "Comment fonctionne le Garbage Collector en Java ?",
          "textResponse": "Le Garbage Collector libère automatiquement la mémoire occupée par les objets qui ne sont plus accessibles dans le programme. Il utilise des algorithmes comme Mark-and-Sweep ou Generational Garbage Collection. Cela améliore la gestion mémoire et évite les fuites, mais le développeur ne contrôle pas directement le moment exact du nettoyage.",
          "keyWords": [
            "Garbage Collector",
            "mémoire",
            "objets inaccessibles",
            "Mark-and-Sweep",
            "Generational Garbage Collection",
            "gestion mémoire",
            "fuites",
            "nettoyage"
          ]
        },
        {
          "question": "Qu'est-ce que la JVM et pourquoi est-elle essentielle ?",
          "textResponse": "La JVM (Java Virtual Machine) est l'environnement d'exécution de Java. Elle exécute le bytecode, gère la mémoire, assure la portabilité via le principe Write Once Run Anywhere et fournit des fonctionnalités comme le Garbage Collector et la gestion des exceptions.",
          "keyWords": [
            "JVM",
            "environnement d'exécution",
            "bytecode",
            "mémoire",
            "Write Once Run Anywhere",
            "Garbage Collector",
            "exceptions"
          ]
        },
        {
          "question": "Quelle est la différence entre Heap et Stack en mémoire Java ?",
          "textResponse": "Le Stack contient les variables locales, les appels de méthodes et est organisé en pile avec allocation rapide. Le Heap contient les objets et est géré par le Garbage Collector. Le Stack est limité et lié au thread, tandis que le Heap est global et partagé par tous les threads.",
          "keyWords": [
            "Stack",
            "variables locales",
            "appels de méthodes",
            "pile",
            "allocation rapide",
            "Heap",
            "objets",
            "Garbage Collector",
            "thread",
            "partagé"
          ]
        },
        {
          "question": "Quelle est la différence entre checked exceptions et unchecked exceptions ?",
          "textResponse": "Les checked exceptions héritent de `Exception` et doivent être déclarées ou gérées avec `try-catch`. Les unchecked exceptions héritent de `RuntimeException` et n'ont pas besoin d'être déclarées. Les checked exceptions représentent des situations prévues, tandis que les unchecked reflètent des erreurs de programmation.",
          "keyWords": [
            "checked exceptions",
            "unchecked exceptions",
            "Exception",
            "RuntimeException",
            "try-catch",
            "situations prévues",
            "erreurs de programmation"
          ]
        },
        {
          "question": "Qu'est-ce que le mot-clé `final` en Java ?",
          "textResponse": "Le mot-clé `final` peut être appliqué aux variables, méthodes et classes. Une variable `final` ne peut pas être réassignée, une méthode `final` ne peut pas être redéfinie, et une classe `final` ne peut pas être héritée. Cela garantit la stabilité et la sécurité du code.",
          "keyWords": [
            "final",
            "variables",
            "méthodes",
            "classes",
            "réassignée",
            "redéfinie",
            "héritée",
            "stabilité",
            "sécurité"
          ]
        },
        {
          "question": "Quelle est la différence entre JDK, JRE et JVM ?",
          "textResponse": "Le JDK (Java Development Kit) est l'outil complet qui inclut le compilateur, les bibliothèques et la JVM pour développer et exécuter des programmes Java. Le JRE (Java Runtime Environment) contient uniquement les bibliothèques et la JVM nécessaires pour exécuter des applications. La JVM (Java Virtual Machine) est le moteur d'exécution qui interprète et exécute le bytecode.",
          "keyWords": [
            "JDK",
            "Java Development Kit",
            "compilateur",
            "bibliothèques",
            "JVM",
            "développer",
            "exécuter",
            "JRE",
            "Java Runtime Environment",
            "bytecode",
            "moteur d'exécution"
          ]
        },
        {
          "question": "Qu'est-ce que la surcharge de méthode en Java ?",
          "textResponse": "La surcharge de méthode consiste à définir plusieurs méthodes avec le même nom mais des signatures différentes, c'est-à-dire un nombre ou un type de paramètres distincts. Elle permet d'améliorer la lisibilité et d'offrir plusieurs variantes d'un même comportement.",
          "keyWords": [
            "surcharge de méthode",
            "même nom",
            "signatures différentes",
            "paramètres",
            "lisibilité",
            "variantes",
            "comportement"
          ]
        },
        {
          "question": "Qu'est-ce que la redéfinition de méthode en Java ?",
          "textResponse": "La redéfinition de méthode consiste à fournir une nouvelle implémentation d'une méthode héritée d'une classe parente. Elle doit conserver la même signature et peut utiliser l'annotation `@Override`. Cela permet d'adapter le comportement aux besoins de la sous-classe.",
          "keyWords": [
            "redéfinition de méthode",
            "implémentation",
            "héritée",
            "classe parente",
            "signature",
            "@Override",
            "sous-classe",
            "adapter le comportement"
          ]
        },
        {
          "question": "Quelle est la différence entre `HashMap` et `TreeMap` ?",
          "textResponse": "Un `HashMap` stocke les clés et valeurs sans ordre particulier et offre une complexité moyenne de O(1) pour les opérations. Un `TreeMap` stocke les éléments triés selon l'ordre naturel ou un comparateur et a une complexité de O(log n).",
          "keyWords": [
            "HashMap",
            "clés",
            "valeurs",
            "ordre",
            "complexité O(1)",
            "TreeMap",
            "tri",
            "ordre naturel",
            "comparateur",
            "complexité O(log n)"
          ]
        },
        {
          "question": "Quelle est la différence entre `ArrayList` et `LinkedList` ?",
          "textResponse": "Un `ArrayList` est basé sur un tableau dynamique et offre un accès rapide par index mais des insertions coûteuses au milieu. Un `LinkedList` est basé sur une liste doublement chaînée et permet des insertions et suppressions rapides mais un accès par index plus lent.",
          "keyWords": [
            "ArrayList",
            "tableau dynamique",
            "accès rapide",
            "index",
            "insertions coûteuses",
            "LinkedList",
            "liste doublement chaînée",
            "insertions rapides",
            "suppressions rapides",
            "accès lent"
          ]
        },
        {
          "question": "Qu'est-ce que le mot-clé `volatile` en Java ?",
          "textResponse": "Le mot-clé `volatile` garantit que les lectures et écritures d'une variable se font directement en mémoire principale et non dans le cache des threads. Il assure la visibilité des changements entre threads mais ne garantit pas l'exclusion mutuelle.",
          "keyWords": [
            "volatile",
            "lectures",
            "écritures",
            "mémoire principale",
            "cache",
            "threads",
            "visibilité",
            "exclusion mutuelle"
          ]
        },
        {
          "question": "Quelle est la différence entre `synchronized` et `Lock` en Java ?",
          "textResponse": "Le mot-clé `synchronized` assure une exclusion mutuelle implicite sur une section critique et est plus simple à utiliser. Les `Lock` comme `ReentrantLock` offrent plus de flexibilité, par exemple essayer de verrouiller, vérifier l'état du verrou ou déverrouiller dans un autre contexte.",
          "keyWords": [
            "synchronized",
            "exclusion mutuelle",
            "section critique",
            "simplicité",
            "Lock",
            "ReentrantLock",
            "flexibilité",
            "verrouiller",
            "déverrouiller"
          ]
        },
        {
          "question": "Quelle est la différence entre `String`, `StringBuilder` et `StringBuffer` ?",
          "textResponse": "`String` est immuable, toute modification crée un nouvel objet. `StringBuilder` est mutable, plus rapide mais non thread-safe. `StringBuffer` est mutable et thread-safe grâce à la synchronisation, mais moins performant que `StringBuilder`.",
          "keyWords": [
            "String",
            "immuable",
            "objet",
            "StringBuilder",
            "mutable",
            "non thread-safe",
            "rapide",
            "StringBuffer",
            "thread-safe",
            "synchronisation",
            "performances"
          ]
        },
        {
          "question": "Qu'est-ce que le mot-clé `static` en Java ?",
          "textResponse": "Le mot-clé `static` permet de déclarer des variables, méthodes ou blocs liés à la classe plutôt qu'à une instance. Les variables `static` sont partagées entre toutes les instances, les méthodes `static` peuvent être appelées sans objet et les blocs `static` s'exécutent lors du chargement de la classe.",
          "keyWords": [
            "static",
            "variables",
            "méthodes",
            "blocs",
            "classe",
            "instance",
            "partagées",
            "appelées sans objet",
            "chargement de la classe"
          ]
        },
        {
          "question": "Quelle est la différence entre `throw` et `throws` en Java ?",
          "textResponse": "`throw` est utilisé pour lancer une exception spécifique à un endroit précis du code. `throws` est utilisé dans la signature d'une méthode pour déclarer les exceptions qu'elle peut propager.",
          "keyWords": [
            "throw",
            "lancer",
            "exception spécifique",
            "throws",
            "signature de méthode",
            "déclarer",
            "propager"
          ]
        },
        {
          "question": "Quelle est la différence entre `Collection` et `Collections` en Java ?",
          "textResponse": "`Collection` est une interface racine qui définit les structures de données comme List, Set et Queue. `Collections` est une classe utilitaire qui fournit des méthodes statiques comme sort, reverse, shuffle et synchronizedList pour manipuler les collections.",
          "keyWords": [
            "Collection",
            "interface",
            "List",
            "Set",
            "Queue",
            "Collections",
            "classe utilitaire",
            "méthodes statiques",
            "sort",
            "reverse",
            "shuffle",
            "synchronizedList"
          ]
        },
        {
          "question": "Quelle est la différence entre `Comparable` et `Comparator` ?",
          "textResponse": "`Comparable` définit un ordre naturel en implémentant la méthode compareTo directement dans la classe. `Comparator` permet de définir plusieurs critères d'ordre externes en implémentant compare et peut être passé comme paramètre aux algorithmes de tri.",
          "keyWords": [
            "Comparable",
            "ordre naturel",
            "compareTo",
            "classe",
            "Comparator",
            "critères d'ordre externes",
            "compare",
            "algorithmes de tri"
          ]
        },
        {
          "question": "Qu'est-ce que le mot-clé `transient` en Java ?",
          "textResponse": "Le mot-clé `transient` indique qu'un champ ne doit pas être sérialisé. Lorsqu'un objet est écrit dans un flux, les variables marquées `transient` ne sont pas sauvegardées, ce qui protège les données sensibles ou inutiles.",
          "keyWords": [
            "transient",
            "champ",
            "sérialisé",
            "flux",
            "variables",
            "non sauvegardées",
            "données sensibles",
            "inutiles"
          ]
        },
        {
          "question": "Quelle est la différence entre `Serializable` et `Externalizable` ?",
          "textResponse": "`Serializable` permet la sérialisation automatique en marquant une classe, tandis que `Externalizable` donne un contrôle total sur le processus en imposant d'implémenter les méthodes writeExternal et readExternal.",
          "keyWords": [
            "Serializable",
            "sérialisation automatique",
            "classe",
            "Externalizable",
            "contrôle total",
            "writeExternal",
            "readExternal"
          ]
        },
        {
          "question": "Qu'est-ce que la réflexion (Reflection) en Java ?",
          "textResponse": "La réflexion permet d'inspecter et de manipuler les classes, méthodes et champs à l'exécution. Elle utilise des classes comme Class, Method et Field. C'est puissant pour des frameworks mais peut réduire la sécurité et les performances.",
          "keyWords": [
            "réflexion",
            "inspecter",
            "manipuler",
            "classes",
            "méthodes",
            "champs",
            "exécution",
            "Class",
            "Method",
            "Field",
            "frameworks",
            "sécurité",
            "performances"
          ]
        },
        {
          "question": "Qu'est-ce que le mot-clé `super` en Java ?",
          "textResponse": "Le mot-clé `super` permet d'accéder aux membres de la classe parente. Il est utilisé pour appeler un constructeur parent ou pour différencier une méthode ou variable héritée d'une sous-classe.",
          "keyWords": [
            "super",
            "classe parente",
            "membres",
            "constructeur parent",
            "méthode héritée",
            "variable héritée",
            "sous-classe"
          ]
        },
        {
          "question": "Quelle est la différence entre `final`, `finally` et `finalize` ?",
          "textResponse": "`final` est un mot-clé pour empêcher la modification de variables, méthodes ou classes. `finally` est un bloc exécuté après un try-catch pour garantir l'exécution de code de nettoyage. `finalize` est une méthode appelée par le Garbage Collector avant la destruction d'un objet.",
          "keyWords": [
            "final",
            "variables",
            "méthodes",
            "classes",
            "finally",
            "try-catch",
            "nettoyage",
            "finalize",
            "Garbage Collector",
            "destruction"
          ]
        },
        {
          "question": "Quelle est la différence entre `List`, `Set` et `Map` ?",
          "textResponse": "Une `List` est une collection ordonnée qui accepte les doublons et permet l'accès par index. Un `Set` est une collection non ordonnée qui interdit les doublons. Un `Map` associe des clés uniques à des valeurs et ne fait pas partie de l'interface Collection.",
          "keyWords": [
            "List",
            "collection ordonnée",
            "doublons",
            "index",
            "Set",
            "non ordonnée",
            "interdit les doublons",
            "Map",
            "clés uniques",
            "valeurs",
            "interface Collection"
          ]
        },
        {
          "question": "Quelle est la différence entre `try-with-resources` et un bloc `try-finally` ?",
          "textResponse": "`try-with-resources` ferme automatiquement les ressources qui implémentent AutoCloseable, réduisant le code boilerplate. Un bloc `try-finally` exige la fermeture manuelle des ressources dans le bloc finally.",
          "keyWords": [
            "try-with-resources",
            "fermer automatiquement",
            "ressources",
            "AutoCloseable",
            "boilerplate",
            "try-finally",
            "fermeture manuelle"
          ]
        },
        {
          "question": "Qu'est-ce que l'annotation @FunctionalInterface ?",
          "textResponse": "L'annotation @FunctionalInterface en Java indique qu'une interface contient exactement une seule méthode abstraite, ce qui la rend utilisable avec les expressions lambda et les références de méthode. Elle permet de définir des interfaces fonctionnelles telles que Runnable ou Comparator.",
          "keyWords": [
            "@FunctionalInterface",
            "interface fonctionnelle",
            "méthode abstraite",
            "lambda",
            "référence de méthode"
          ]
        },
        {
          "question": "Qu'est-ce qu'un Stream en Java ?",
          "textResponse": "Un Stream en Java est une séquence d’éléments qui permet de traiter des données de manière déclarative et fonctionnelle. Il offre des opérations comme filter, map, reduce et peut travailler en mode séquentiel ou parallèle.",
          "keyWords": [
            "Stream",
            "séquence d’éléments",
            "déclaratif",
            "fonctionnel",
            "filter",
            "map",
            "reduce",
            "séquentiel",
            "parallèle"
          ]
        },
        {
          "question": "Quelle est la différence entre un Stream et une Collection ?",
          "textResponse": "Une Collection stocke et organise des données en mémoire tandis qu’un Stream ne stocke rien, il représente un pipeline d’opérations appliquées aux données. Les Collections sont orientées stockage, les Streams orientés traitement.",
          "keyWords": [
            "Stream",
            "Collection",
            "stockage",
            "pipeline",
            "traitement"
          ]
        },
        {
          "question": "Comment crée-t-on un Stream à partir d'une Collection ?",
          "textResponse": "On crée un Stream à partir d’une Collection en utilisant la méthode stream() pour un flux séquentiel ou parallelStream() pour un flux parallèle.",
          "keyWords": [
            "Stream",
            "Collection",
            "stream()",
            "parallelStream()",
            "séquentiel",
            "parallèle"
          ]
        },
        {
          "question": "Quelles sont les deux catégories principales d'opérations sur un Stream ?",
          "textResponse": "Les opérations sur un Stream se divisent en opérations intermédiaires, qui transforment le flux et renvoient un nouveau Stream (comme filter, map, distinct), et en opérations terminales, qui produisent un résultat concret (comme collect, reduce, forEach).",
          "keyWords": [
            "Stream",
            "opérations intermédiaires",
            "opérations terminales",
            "filter",
            "map",
            "collect",
            "reduce",
            "forEach"
          ]
        },
        {
          "question": "Comment fonctionne la notion de lazy evaluation dans les Streams ?",
          "textResponse": "La lazy evaluation signifie que les opérations intermédiaires d’un Stream ne sont pas exécutées immédiatement. Elles sont évaluées uniquement lorsqu’une opération terminale est appelée, ce qui optimise les performances et évite des calculs inutiles.",
          "keyWords": [
            "Stream",
            "lazy evaluation",
            "opérations intermédiaires",
            "opération terminale",
            "optimisation"
          ]
        },
        {
          "question": "Qu'est-ce que l'opération filter() dans un Stream ?",
          "textResponse": "L’opération filter() dans un Stream permet de conserver uniquement les éléments qui satisfont un prédicat donné, en renvoyant un nouveau flux contenant ces éléments.",
          "keyWords": [
            "Stream",
            "filter()",
            "prédicat",
            "éléments",
            "nouveau flux"
          ]
        },
        {
          "question": "Que fait la méthode map() dans un Stream ?",
          "textResponse": "La méthode map() applique une fonction de transformation à chaque élément d’un Stream et renvoie un nouveau flux contenant les résultats transformés.",
          "keyWords": [
            "Stream",
            "map()",
            "transformation",
            "nouveau flux",
            "éléments"
          ]
        },
        {
          "question": "Comment transformer un Stream en liste ou autre collection ?",
          "textResponse": "On transforme un Stream en liste ou autre collection en utilisant l’opération terminale collect() avec Collectors comme Collectors.toList(), Collectors.toSet() ou Collectors.toMap().",
          "keyWords": [
            "Stream",
            "collect()",
            "Collectors",
            "toList()",
            "toSet()",
            "toMap()",
            "collection"
          ]
        },
        {
          "question": "Quelle est la différence entre forEach() et collect() dans un Stream ?",
          "textResponse": "forEach() parcourt chaque élément d’un Stream pour exécuter une action sans renvoyer de structure, tandis que collect() agrège les éléments du Stream dans une collection ou un autre résultat concret.",
          "keyWords": [
            "Stream",
            "forEach()",
            "collect()",
            "parcourir",
            "agréger",
            "résultat concret"
          ]
        },
        {
          "question": "Que signifie un Stream parallèle et quand l'utiliser ?",
          "textResponse": "Un Stream parallèle divise ses éléments en sous-tâches traitées en parallèle par plusieurs threads. On l’utilise pour traiter de grands volumes de données lorsque les opérations sont indépendantes et non synchronisées.",
          "keyWords": [
            "Stream",
            "parallèle",
            "threads",
            "sous-tâches",
            "indépendantes",
            "grands volumes"
          ]
        },
        {
          "question": "Quelle est la différence entre un Stream séquentiel et parallèle ?",
          "textResponse": "Un Stream séquentiel traite les éléments un par un dans un seul thread tandis qu’un Stream parallèle divise le travail entre plusieurs threads, permettant une exécution concurrente mais nécessitant une attention à la synchronisation et au coût du parallélisme.",
          "keyWords": [
            "Stream",
            "séquentiel",
            "parallèle",
            "thread",
            "concurrence",
            "synchronisation"
          ]
        },
        {
          "question": "Comment mesurer les performances d'un Stream parallèle par rapport à un Stream séquentiel ?",
          "textResponse": "On mesure les performances en chronométrant l’exécution des opérations avec des outils comme System.nanoTime() ou des frameworks de benchmarking (par ex. JMH). Il faut comparer les temps d’exécution pour déterminer si le parallélisme apporte un gain réel.",
          "keyWords": [
            "Stream",
            "performances",
            "séquentiel",
            "parallèle",
            "System.nanoTime()",
            "JMH",
            "benchmarking"
          ]
        },
        {
          "question": "Quelles méthodes utilisent des fonctions lambda dans le Stream API ?",
          "textResponse": "Dans le Stream API, des méthodes comme filter(), map(), forEach(), reduce() et sorted() utilisent des fonctions lambda pour exprimer la logique de transformation ou de filtrage.",
          "keyWords": [
            "Stream API",
            "lambda",
            "filter()",
            "map()",
            "forEach()",
            "reduce()",
            "sorted()"
          ]
        },
        {
          "question": "Comment chaîner plusieurs opérations sur un Stream ?",
          "textResponse": "On chaîne plusieurs opérations en appelant successivement des méthodes intermédiaires comme filter(), map(), distinct(), suivies d’une opération terminale comme collect() ou forEach().",
          "keyWords": [
            "Stream",
            "chaînage",
            "opérations intermédiaires",
            "filter()",
            "map()",
            "distinct()",
            "collect()",
            "forEach()"
          ]
        },
        {
          "question": "Comment gérer des exceptions dans les opérations sur un Stream ?",
          "textResponse": "Pour gérer des exceptions dans un Stream, on encapsule la logique des lambdas dans un bloc try-catch ou on utilise des méthodes utilitaires qui transforment les exceptions vérifiées en exceptions non vérifiées.",
          "keyWords": [
            "Stream",
            "exceptions",
            "lambda",
            "try-catch",
            "exceptions vérifiées",
            "non vérifiées"
          ]
        },
        {
          "question": "Que fait la méthode distinct() dans un Stream ?",
          "textResponse": "La méthode distinct() élimine les doublons d’un Stream en comparant les éléments selon equals() et renvoie un nouveau flux ne contenant que des valeurs uniques.",
          "keyWords": [
            "Stream",
            "distinct()",
            "doublons",
            "equals()",
            "valeurs uniques"
          ]
        },
        {
          "question": "Qu'est-ce qu'un thread en Java ?",
          "textResponse": "Un thread en Java est une unité d’exécution indépendante qui permet de réaliser plusieurs tâches en parallèle dans un programme. Il est géré par la JVM et peut être créé en étendant la classe Thread ou en implémentant l’interface Runnable.",
          "keyWords": [
            "thread",
            "Java",
            "exécution parallèle",
            "JVM",
            "classe Thread",
            "interface Runnable"
          ]
        }
      ]
    },
    {
      "topic": "Angular",
      "questions": [
        {
          "question": "Qu'est-ce qu'Angular ?",
          "textResponse": "Angular est un framework front-end open-source développé par Google, basé sur TypeScript, qui permet de créer des applications web dynamiques, modulaires et maintenables grâce à une architecture orientée composants.",
          "keyWords": [
            "Angular",
            "framework",
            "front-end",
            "TypeScript",
            "Google",
            "composants",
            "applications web",
            "modulaire",
            "maintenable"
          ]
        },
        {
          "question": "Quelle est la différence entre AngularJS (1.x) et Angular (2 et versions supérieures) ?",
          "textResponse": "AngularJS est basé sur JavaScript et utilise le concept de scope et de contrôleurs, tandis qu’Angular (2+) est basé sur TypeScript, suit une architecture orientée composants, est plus performant et supporte mieux le mobile et les grandes applications.",
          "keyWords": [
            "AngularJS",
            "Angular",
            "TypeScript",
            "JavaScript",
            "scope",
            "contrôleurs",
            "composants",
            "performances",
            "mobile"
          ]
        },
        {
          "question": "Qu'est-ce qu'un composant dans Angular ?",
          "textResponse": "Un composant est l’unité de base dans Angular qui combine une logique TypeScript, un template HTML et un style CSS, permettant de construire une interface utilisateur modulaire et réutilisable.",
          "keyWords": [
            "composant",
            "Angular",
            "TypeScript",
            "HTML",
            "CSS",
            "interface utilisateur",
            "modulaire",
            "réutilisable"
          ]
        },
        {
          "question": "Que signifie 'Two-way data binding' dans Angular ?",
          "textResponse": "Le Two-way data binding est un mécanisme qui synchronise automatiquement les données entre le modèle (component) et la vue (template), de sorte que toute modification d’un côté est immédiatement reflétée de l’autre.",
          "keyWords": [
            "Two-way data binding",
            "Angular",
            "synchronisation",
            "modèle",
            "vue",
            "component",
            "template"
          ]
        },
        {
          "question": "Qu'est-ce qu'un module Angular ?",
          "textResponse": "Un module Angular est une unité organisationnelle qui regroupe des composants, des directives, des pipes et des services, permettant de structurer et charger des fonctionnalités de manière modulaire dans une application.",
          "keyWords": [
            "module",
            "Angular",
            "composants",
            "directives",
            "pipes",
            "services",
            "organisation",
            "modulaire"
          ]
        },
         {
        "question": "Qu'est-ce qu'un décorateur en Angular ?",
        "textResponse": "En Angular, un décorateur est une fonction qui permet d'ajouter des métadonnées à une classe, une propriété ou une méthode, afin que le framework puisse les traiter et appliquer certains comportements. Par exemple, @Component définit une classe comme un composant Angular.",
        "keyWords": ["décorateur", "Angular", "métadonnées", "@Component", "classe", "propriété", "méthode"]
        },
        {
          "question": "Qu'est-ce qu'un `@Component` ?",
          "textResponse": "`@Component` est un décorateur Angular qui définit la configuration d’un composant, notamment son sélecteur, son template et ses styles, et permet ainsi à Angular de comprendre comment instancier et afficher ce composant.",
          "keyWords": [
            "@Component",
            "décorateur",
            "Angular",
            "sélecteur",
            "template",
            "styles",
            "composant"
          ]
        },
        {
          "question": "Comment déclarer un composant dans Angular ?",
          "textResponse": "Un composant est déclaré en créant une classe TypeScript annotée avec `@Component`, et en l’ajoutant ensuite dans la section 'declarations' du module Angular correspondant.",
          "keyWords": [
            "déclarer",
            "composant",
            "@Component",
            "TypeScript",
            "Angular",
            "module",
            "declarations"
          ]
        },
        {
          "question": "Que sont les directives en Angular ?",
          "textResponse": "Les directives en Angular sont des classes qui permettent de manipuler le DOM ou d’ajouter des comportements aux éléments du template. Elles complètent et enrichissent les composants.",
          "keyWords": [
            "directives",
            "Angular",
            "DOM",
            "template",
            "comportement",
            "composants"
          ]
        },
        {
          "question": "Quelle est la différence entre une directive structurelle et une directive d'attribut ?",
          "textResponse": "Une directive structurelle modifie la structure du DOM (par exemple `*ngIf`, `*ngFor`), tandis qu’une directive d’attribut modifie l’apparence ou le comportement d’un élément existant (par exemple `ngClass`, `ngStyle`).",
          "keyWords": [
            "directive structurelle",
            "directive d'attribut",
            "DOM",
            "ngIf",
            "ngFor",
            "ngClass",
            "ngStyle"
          ]
        },
        {
          "question": "Qu'est-ce qu'un service Angular ?",
          "textResponse": "Un service Angular est une classe qui contient de la logique métier ou des fonctions réutilisables, souvent utilisées pour gérer les données, effectuer des appels HTTP ou partager des informations entre composants.",
          "keyWords": [
            "service",
            "Angular",
            "logique métier",
            "réutilisable",
            "données",
            "HTTP",
            "partage",
            "composants"
          ]
        },
        {
          "question": "Quelle est la différence entre `ngOnInit` et `constructor` dans un composant ?",
          "textResponse": "Le `constructor` sert à initialiser la classe et injecter des dépendances, tandis que `ngOnInit` est une méthode du cycle de vie Angular appelée après l’initialisation du composant, idéale pour charger des données ou exécuter une logique.",
          "keyWords": [
            "constructor",
            "ngOnInit",
            "cycle de vie",
            "Angular",
            "dépendances",
            "initialisation",
            "composant"
          ]
        },
        {
          "question": "Comment gérer les formulaires dans Angular ?",
          "textResponse": "Les formulaires dans Angular peuvent être gérés via deux approches : les formulaires basés sur le modèle (template-driven) et les formulaires réactifs (reactive forms), offrant respectivement simplicité et flexibilité avec une gestion plus robuste des données.",
          "keyWords": [
            "formulaires",
            "Angular",
            "template-driven",
            "reactive forms",
            "saisie",
            "validation"
          ]
        },
        {
          "question": "Quelle est la différence entre un formulaire réactif et un formulaire basé sur le modèle ?",
          "textResponse": "Un formulaire basé sur le modèle utilise le template HTML avec des directives Angular (`ngModel`), tandis qu’un formulaire réactif repose sur une gestion explicite via des objets `FormControl` et `FormGroup` dans le code TypeScript.",
          "keyWords": [
            "formulaire réactif",
            "formulaire basé sur le modèle",
            "ngModel",
            "FormControl",
            "FormGroup",
            "Angular"
          ]
        },
        {
          "question": "Comment lier un modèle (binding) dans Angular ?",
          "textResponse": "Le binding dans Angular peut être fait de quatre façons : interpolation `{{ }}`, binding d’attribut `[property]`, binding d’événement `(event)` et binding bidirectionnel `[(ngModel)]`.",
          "keyWords": [
            "binding",
            "Angular",
            "interpolation",
            "property binding",
            "event binding",
            "two-way binding",
            "ngModel"
          ]
        },
        {
          "question": "Que sont les observables dans Angular ?",
          "textResponse": "Les observables dans Angular (via RxJS) sont des flux asynchrones de données qui permettent de gérer des événements, des requêtes HTTP et des valeurs dynamiques, avec des opérateurs puissants pour la transformation et le filtrage.",
          "keyWords": [
            "observables",
            "Angular",
            "RxJS",
            "flux",
            "asynchrone",
            "événements",
            "HTTP",
            "opérateurs"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `@Input()` et un `@Output()` dans Angular ?",
          "textResponse": "`@Input()` permet de recevoir des données d’un composant parent, tandis que `@Output()` permet d’émettre des événements vers le parent à l’aide d’un EventEmitter.",
          "keyWords": [
            "@Input",
            "@Output",
            "Angular",
            "parent",
            "enfant",
            "EventEmitter",
            "données",
            "événements"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `ngFor` ?",
          "textResponse": "`ngFor` est une directive structurelle Angular qui permet d’itérer sur une collection et de générer dynamiquement un élément du DOM pour chaque élément de la liste.",
          "keyWords": [
            "ngFor",
            "directive structurelle",
            "Angular",
            "DOM",
            "collection",
            "itération"
          ]
        },
        {
          "question": "Comment gérer les événements dans Angular ?",
          "textResponse": "Les événements dans Angular sont gérés avec le binding `(event)`, où un événement du DOM (comme click) est associé à une méthode du composant.",
          "keyWords": [
            "événements",
            "Angular",
            "binding",
            "event binding",
            "DOM",
            "méthode",
            "click"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `ngIf` ?",
          "textResponse": "`ngIf` est une directive structurelle Angular qui ajoute ou supprime un élément du DOM en fonction d’une condition booléenne.",
          "keyWords": [
            "ngIf",
            "directive structurelle",
            "Angular",
            "DOM",
            "condition"
          ]
        },
        {
          "question": "Comment utiliser la méthode `HttpClient` dans Angular ?",
          "textResponse": "Le service `HttpClient` d’Angular permet de réaliser des requêtes HTTP (GET, POST, PUT, DELETE) de manière asynchrone et retourne des observables pour traiter les réponses.",
          "keyWords": [
            "HttpClient",
            "Angular",
            "HTTP",
            "GET",
            "POST",
            "PUT",
            "DELETE",
            "observables",
            "asynchrone"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `Observable` en Angular ?",
          "textResponse": "Un Observable en Angular est un flux de données asynchrone fourni par RxJS qui permet de gérer des événements, des appels HTTP ou des données dynamiques, avec des méthodes pour s'abonner et transformer les valeurs au fil du temps.",
          "keyWords": [
            "Observable",
            "Angular",
            "RxJS",
            "flux",
            "données",
            "asynchrone",
            "événements",
            "HTTP",
            "abonnement",
            "transformation"
          ]
        },
        {
          "question": "Quelle est la différence entre `Promise` et `Observable` ?",
          "textResponse": "Une Promise gère une seule valeur asynchrone résolue ou rejetée une fois, tandis qu’un Observable peut émettre plusieurs valeurs sur le temps, être annulé et offre des opérateurs pour la composition et la transformation des flux.",
          "keyWords": [
            "Promise",
            "Observable",
            "asynchrone",
            "valeur unique",
            "plusieurs valeurs",
            "annulation",
            "opérateurs",
            "flux"
          ]
        },
        {
          "question": "Qu'est-ce que le `RxJS` et comment est-il utilisé dans Angular ?",
          "textResponse": "RxJS est une bibliothèque pour la programmation réactive avec des observables. Dans Angular, il est utilisé pour gérer les flux asynchrones comme les événements utilisateur, les requêtes HTTP et la communication entre composants.",
          "keyWords": [
            "RxJS",
            "Angular",
            "programmation réactive",
            "observables",
            "asynchrone",
            "événements",
            "HTTP",
            "communication"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `@Injectable()` ?",
          "textResponse": "`@Injectable()` est un décorateur qui marque une classe comme pouvant être injectée en tant que service dans Angular, permettant à l’injecteur de gérer sa création et sa durée de vie.",
          "keyWords": [
            "@Injectable",
            "Angular",
            "service",
            "injection",
            "injecteur",
            "création",
            "durée de vie"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `router-outlet` ?",
          "textResponse": "`router-outlet` est une directive Angular utilisée dans le template pour indiquer où les composants liés aux routes doivent être affichés dans l’application.",
          "keyWords": [
            "router-outlet",
            "Angular",
            "directive",
            "template",
            "routes",
            "composants",
            "affichage"
          ]
        },
        {
          "question": "Qu'est-ce que le `routing` dans Angular ?",
          "textResponse": "Le routing dans Angular permet de naviguer entre différentes vues ou composants de l’application via des routes définies dans le module de routage, facilitant la création d’applications à pages multiples.",
          "keyWords": [
            "routing",
            "Angular",
            "navigation",
            "vues",
            "composants",
            "routes",
            "pages multiples"
          ]
        },
        {
          "question": "Comment gérer la navigation dans Angular ?",
          "textResponse": "La navigation dans Angular est gérée avec le Router, en utilisant soit `routerLink` dans les templates pour les liens, soit la méthode `navigate()` du Router pour la navigation programmatique.",
          "keyWords": [
            "navigation",
            "Angular",
            "Router",
            "routerLink",
            "navigate()",
            "programmatique",
            "template"
          ]
        },
        {
          "question": "Qu'est-ce que `routerLink` ?",
          "textResponse": "`routerLink` est une directive Angular utilisée dans les templates pour créer des liens vers des routes définies dans le module de routage, permettant de naviguer sans recharger la page.",
          "keyWords": [
            "routerLink",
            "Angular",
            "directive",
            "template",
            "routes",
            "navigation",
            "SPA"
          ]
        },
        {
          "question": "Quelle est la différence entre `path` et `component` dans la configuration du routeur Angular ?",
          "textResponse": "`path` définit l’URL associée à une route tandis que `component` indique le composant Angular qui sera rendu lorsque cette route est activée.",
          "keyWords": [
            "path",
            "component",
            "route",
            "Angular",
            "URL",
            "composant",
            "rendu"
          ]
        },
        {
          "question": "Comment gérer les paramètres de route dans Angular ?",
          "textResponse": "Les paramètres de route sont accessibles via `ActivatedRoute` dans le composant, permettant de récupérer les paramètres statiques, dynamiques ou de requête et de les utiliser dans la logique du composant.",
          "keyWords": [
            "paramètres",
            "route",
            "Angular",
            "ActivatedRoute",
            "statique",
            "dynamique",
            "requête",
            "composant"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `pipe` dans Angular ?",
          "textResponse": "Un pipe Angular est une fonction qui transforme les valeurs affichées dans le template, comme la mise en forme de dates, de nombres ou de textes, sans modifier les données sources.",
          "keyWords": [
            "pipe",
            "Angular",
            "transformation",
            "template",
            "format",
            "dates",
            "nombres",
            "texte"
          ]
        },
        {
          "question": "Comment créer un `pipe` personnalisé ?",
          "textResponse": "Pour créer un pipe personnalisé, on définit une classe TypeScript annotée avec `@Pipe` et qui implémente la méthode `transform()`, puis on l’ajoute dans la section 'declarations' du module Angular.",
          "keyWords": [
            "pipe",
            "personnalisé",
            "Angular",
            "@Pipe",
            "transform()",
            "TypeScript",
            "module",
            "declarations"
          ]
        },
        {
          "question": "Quelle est la différence entre `async` et `await` dans Angular ?",
          "textResponse": "`async` et `await` sont utilisés avec les Promises pour simplifier la gestion asynchrone : `async` marque une fonction qui retourne une Promise et `await` pause l’exécution jusqu’à ce que la Promise soit résolue.",
          "keyWords": [
            "async",
            "await",
            "Angular",
            "Promise",
            "asynchrone",
            "exécution",
            "résolution"
          ]
        },
        {
          "question": "Qu'est-ce que la gestion de la dépendance dans Angular ?",
          "textResponse": "La gestion de la dépendance (Dependency Injection) dans Angular permet d’injecter automatiquement des services ou des classes dans des composants, directives ou pipes, centralisant la création et le partage des instances.",
          "keyWords": [
            "dependency injection",
            "Angular",
            "services",
            "composants",
            "directives",
            "pipes",
            "injection",
            "instances"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `ngModel` et comment l'utiliser ?",
          "textResponse": "`ngModel` est une directive Angular qui permet le binding bidirectionnel entre un élément du template et une propriété du composant, utilisée principalement dans les formulaires.",
          "keyWords": [
            "ngModel",
            "Angular",
            "binding bidirectionnel",
            "template",
            "propriété",
            "composant",
            "formulaires"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `template-driven form` ?",
          "textResponse": "Un template-driven form est un formulaire Angular où la structure, la validation et le binding sont définis directement dans le template HTML en utilisant des directives comme `ngModel` et `required`.",
          "keyWords": [
            "template-driven form",
            "Angular",
            "formulaire",
            "template",
            "ngModel",
            "validation",
            "directives"
          ]
        },
        {
          "question": "Comment fonctionne la validation dans Angular ?",
          "textResponse": "La validation dans Angular peut être réalisée avec des validateurs intégrés (comme required, minLength) ou personnalisés, appliqués aux formulaires réactifs ou template-driven pour vérifier la validité des données avant soumission.",
          "keyWords": [
            "validation",
            "Angular",
            "validateurs",
            "formulaires réactifs",
            "template-driven",
            "données"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `ngClass` ?",
          "textResponse": "`ngClass` est une directive Angular qui permet d’ajouter ou de supprimer dynamiquement des classes CSS à un élément en fonction de conditions ou d’objets dans le composant.",
          "keyWords": [
            "ngClass",
            "Angular",
            "directive",
            "classes CSS",
            "dynamique",
            "conditions",
            "composant"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `ngStyle` ?",
          "textResponse": "`ngStyle` est une directive Angular qui permet de modifier dynamiquement les styles CSS d’un élément en fonction des propriétés du composant.",
          "keyWords": [
            "ngStyle",
            "Angular",
            "directive",
            "styles CSS",
            "dynamique",
            "composant"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `formControl` ?",
          "textResponse": "`formControl` est un objet Angular utilisé dans les formulaires réactifs pour gérer l’état et la valeur d’un champ individuel, permettant la validation et l’interaction programmatique avec le formulaire.",
          "keyWords": [
            "formControl",
            "Angular",
            "formulaires réactifs",
            "valeur",
            "état",
            "validation",
            "programme"
          ]
        },
        {
          "question": "Qu'est-ce que le `Lazy Loading` dans Angular ?",
          "textResponse": "Le Lazy Loading dans Angular est une technique qui consiste à charger des modules uniquement lorsqu’ils sont nécessaires, réduisant le temps de chargement initial et optimisant les performances de l’application.",
          "keyWords": [
            "Lazy Loading",
            "Angular",
            "modules",
            "chargement différé",
            "performances",
            "optimisation"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `Service Worker` en Angular ?",
          "textResponse": "Un Service Worker est un script qui s’exécute en arrière-plan dans le navigateur et permet de gérer le cache, les notifications push et le fonctionnement hors-ligne dans les applications Angular PWA.",
          "keyWords": [
            "Service Worker",
            "Angular",
            "script",
            "cache",
            "notifications push",
            "hors-ligne",
            "PWA"
          ]
        },
        {
          "question": "Comment gérez-vous la gestion des erreurs dans Angular ?",
          "textResponse": "La gestion des erreurs dans Angular peut se faire via les blocs try-catch, les opérateurs RxJS comme catchError pour les Observables, et les services globaux pour intercepter et centraliser les erreurs dans l’application.",
          "keyWords": [
            "gestion des erreurs",
            "Angular",
            "try-catch",
            "RxJS",
            "catchError",
            "Observables",
            "service global"
          ]
        },
        {
          "question": "Qu'est-ce que `ngSwitch` ?",
          "textResponse": "`ngSwitch` est une directive structurelle Angular utilisée pour afficher un élément parmi plusieurs options en fonction d’une expression, similaire à un switch-case en JavaScript.",
          "keyWords": [
            "ngSwitch",
            "directive structurelle",
            "Angular",
            "expression",
            "switch-case",
            "affichage conditionnel"
          ]
        },
        {
          "question": "Qu'est-ce que l'injection de dépendances dans Angular ?",
          "textResponse": "L’injection de dépendances (Dependency Injection) dans Angular est un mécanisme qui permet de fournir automatiquement des instances de services ou d’objets aux composants, directives et pipes, facilitant la modularité et le test unitaire.",
          "keyWords": [
            "injection de dépendances",
            "Angular",
            "Dependency Injection",
            "services",
            "composants",
            "modularité",
            "test unitaire"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `HttpInterceptor` ?",
          "textResponse": "Un HttpInterceptor est un service Angular qui intercepte toutes les requêtes et réponses HTTP, permettant de modifier les en-têtes, gérer les erreurs globalement ou ajouter des tokens d’authentification.",
          "keyWords": [
            "HttpInterceptor",
            "Angular",
            "requêtes HTTP",
            "réponses HTTP",
            "interception",
            "en-têtes",
            "authentification",
            "gestion des erreurs"
          ]
        },
        {
          "question": "Quelle est la différence entre `ngOnInit` et `ngAfterViewInit` ?",
          "textResponse": "`ngOnInit` est appelé après l’initialisation des propriétés liées aux entrées du composant, tandis que `ngAfterViewInit` est appelé après que les vues et les composants enfants ont été initialisés, utile pour accéder au DOM ou aux enfants.",
          "keyWords": [
            "ngOnInit",
            "ngAfterViewInit",
            "Angular",
            "initialisation",
            "composants enfants",
            "DOM"
          ]
        },
        {
          "question": "Qu'est-ce que `ngOnDestroy` ?",
          "textResponse": "`ngOnDestroy` est un hook du cycle de vie Angular appelé juste avant la destruction d’un composant ou d’une directive, utilisé pour nettoyer les subscriptions, timers ou ressources afin d’éviter les fuites mémoire.",
          "keyWords": [
            "ngOnDestroy",
            "Angular",
            "cycle de vie",
            "composant",
            "directive",
            "subscriptions",
            "fuites mémoire"
          ]
        },
        {
          "question": "Qu'est-ce que la gestion d'état (state management) dans Angular ?",
          "textResponse": "La gestion d’état dans Angular consiste à centraliser et contrôler l’état de l’application pour garantir la cohérence des données, souvent avec des bibliothèques comme NgRx ou Akita.",
          "keyWords": [
            "gestion d'état",
            "Angular",
            "centralisation",
            "cohérence",
            "NgRx",
            "Akita",
            "application"
          ]
        },
        {
          "question": "Qu'est-ce que `ChangeDetectionStrategy.OnPush` ?",
          "textResponse": "`ChangeDetectionStrategy.OnPush` est une stratégie de détection des changements Angular qui ne vérifie un composant que lorsque ses inputs changent, améliorant les performances des applications complexes.",
          "keyWords": [
            "ChangeDetectionStrategy.OnPush",
            "Angular",
            "détection des changements",
            "inputs",
            "performances"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `ng-content` et comment fonctionne-t-il ?",
          "textResponse": "`ng-content` est une directive Angular utilisée pour insérer du contenu provenant d’un composant parent dans le template d’un composant enfant, facilitant la création de composants réutilisables et flexibles.",
          "keyWords": [
            "ng-content",
            "Angular",
            "directive",
            "contenu",
            "composant parent",
            "composant enfant",
            "réutilisable"
          ]
        },
        {
          "question": "Comment fonctionne le `zone.js` dans Angular ?",
          "textResponse": "Zone.js est une bibliothèque utilisée par Angular pour détecter automatiquement les changements asynchrones (Promesses, événements, timers) et déclencher la détection de changements sans intervention manuelle.",
          "keyWords": [
            "zone.js",
            "Angular",
            "asynchrone",
            "Promesse",
            "événements",
            "timers",
            "détection de changements"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `ng-template` ?",
          "textResponse": "`ng-template` est une balise Angular utilisée pour définir des templates réutilisables ou conditionnels dans le DOM, qui ne sont pas rendus tant qu’ils ne sont pas référencés par une directive comme `ngIf` ou `ngFor`.",
          "keyWords": [
            "ng-template",
            "Angular",
            "template",
            "réutilisable",
            "conditionnel",
            "DOM",
            "ngIf",
            "ngFor"
          ]
        },
        {
          "question": "Qu'est-ce que le `dependency injection` dans Angular ?",
          "textResponse": "Le dependency injection dans Angular permet de fournir automatiquement des instances de services aux composants, directives et pipes, améliorant la modularité, la testabilité et la gestion centralisée des dépendances.",
          "keyWords": [
            "dependency injection",
            "Angular",
            "services",
            "composants",
            "modularité",
            "testabilité",
            "dépendances"
          ]
        },
        {
          "question": "Qu'est-ce que le concept de `Observables` et comment l'utiliser avec `HttpClient` ?",
          "textResponse": "Les Observables permettent de gérer des flux asynchrones dans Angular. Avec HttpClient, ils sont utilisés pour effectuer des requêtes HTTP et s’abonner aux réponses, offrant des opérateurs pour transformer, filtrer ou combiner les données.",
          "keyWords": [
            "Observables",
            "Angular",
            "HttpClient",
            "flux asynchrone",
            "requêtes HTTP",
            "abonnement",
            "opérateurs"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `Component Lifecycle Hook` ?",
          "textResponse": "Un Component Lifecycle Hook est une méthode spéciale dans un composant Angular qui permet d’exécuter du code à différentes étapes du cycle de vie d’un composant, comme ngOnInit, ngAfterViewInit ou ngOnDestroy.",
          "keyWords": [
            "Component Lifecycle Hook",
            "Angular",
            "composant",
            "cycle de vie",
            "ngOnInit",
            "ngAfterViewInit",
            "ngOnDestroy"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `ngFor` avec index ?",
          "textResponse": "`ngFor` avec index est une directive Angular qui permet d’itérer sur une collection tout en exposant la position actuelle de chaque élément via la variable `index`.",
          "keyWords": [
            "ngFor",
            "Angular",
            "directive",
            "index",
            "itération",
            "collection"
          ]
        },
        {
          "question": "Qu'est-ce que le `trackBy` dans une boucle `ngFor` ?",
          "textResponse": "`trackBy` est une option dans `ngFor` qui permet de fournir une fonction pour identifier les éléments uniques d’une collection, optimisant ainsi la détection des changements et la performance lors du rendu.",
          "keyWords": [
            "trackBy",
            "ngFor",
            "Angular",
            "éléments uniques",
            "détection des changements",
            "performance"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `ng-container` ?",
          "textResponse": "`ng-container` est une balise Angular qui ne génère pas de DOM propre mais sert de wrapper logique pour appliquer des directives structurelles ou regrouper des éléments dans le template.",
          "keyWords": [
            "ng-container",
            "Angular",
            "template",
            "wrapper",
            "directive structurelle",
            "DOM"
          ]
        },
        {
          "question": "Qu'est-ce qu'un `@ViewChild` ?",
          "textResponse": "`@ViewChild` est un décorateur Angular qui permet d’accéder à un élément DOM ou à un composant enfant depuis le composant parent, facilitant l’interaction et la manipulation programmée du template.",
          "keyWords": [
            "@ViewChild",
            "Angular",
            "décorateur",
            "DOM",
            "composant enfant",
            "interaction",
            "template"
          ]
        }
      ]
    },
    {
      "topic": "Spring Boot",
      "questions": [{
        "question": "Qu'est-ce que Spring Boot ?",
        "textResponse": "Spring Boot est un framework basé sur Spring qui simplifie la création d’applications Java autonomes, avec une configuration minimale, des conventions par défaut et des dépendances prêtes à l’emploi pour accélérer le développement.",
        "keyWords": ["Spring Boot", "framework", "Spring", "applications Java", "autonomes", "configuration minimale", "conventions", "dépendances", "développement"]
      },
        {
          "question": "Quelle est la différence entre Spring et Spring Boot ?",
          "textResponse": "Spring est un framework général pour le développement Java, nécessitant une configuration manuelle, tandis que Spring Boot fournit des conventions, des starters et un démarrage simplifié pour créer rapidement des applications Spring prêtes à l’emploi.",
          "keyWords": ["Spring", "Spring Boot", "framework", "Java", "configuration", "starters", "conventions", "applications", "simplifié"]
        },
        {
          "question": "Comment créer un projet Spring Boot ?",
          "textResponse": "Un projet Spring Boot peut être créé via Spring Initializr, Maven, Gradle ou en configurant manuellement un projet avec les dépendances nécessaires, en choisissant le packaging, la version Java et les starters adaptés.",
          "keyWords": ["Spring Boot", "projet", "Spring Initializr", "Maven", "Gradle", "dépendances", "packaging", "Java", "starters"]
        },
        {
          "question": "Qu'est-ce que le fichier `application.properties` ?",
          "textResponse": "Le fichier `application.properties` permet de centraliser la configuration de l’application Spring Boot, comme les ports, la connexion aux bases de données, les paramètres de sécurité et d’autres propriétés spécifiques à l’environnement.",
          "keyWords": ["application.properties", "Spring Boot", "configuration", "ports", "base de données", "sécurité", "propriétés", "environnement"]
        },
        {
          "question": "Qu'est-ce qu'une dépendance starter dans Spring Boot ?",
          "textResponse": "Une dépendance starter est un package qui regroupe plusieurs dépendances nécessaires pour une fonctionnalité spécifique, simplifiant la configuration et permettant d’ajouter facilement des modules comme web, JPA ou sécurité.",
          "keyWords": ["dépendance starter", "Spring Boot", "package", "dépendances", "fonctionnalité", "configuration", "modules", "web", "JPA", "sécurité"]
        },
        {
          "question": "Qu'est-ce que l'annotation `@SpringBootApplication` ?",
          "textResponse": "`@SpringBootApplication` est une annotation combinant `@Configuration`, `@EnableAutoConfiguration` et `@ComponentScan`, marquant la classe principale d’une application Spring Boot et activant la configuration automatique et la découverte des beans.",
          "keyWords": ["@SpringBootApplication", "Spring Boot", "Configuration", "EnableAutoConfiguration", "ComponentScan", "classe principale", "configuration automatique", "beans"]
        },
        {
          "question": "Comment lancer une application Spring Boot ?",
          "textResponse": "Une application Spring Boot peut être lancée via la méthode `main()` de la classe annotée `@SpringBootApplication`, en exécutant le jar avec `java -jar` ou directement depuis un IDE supportant Spring Boot.",
          "keyWords": ["Spring Boot", "lancer", "main()", "@SpringBootApplication", "jar", "java -jar", "IDE"]
        },
        {
          "question": "Que fait l'annotation `@RestController` ?",
          "textResponse": "`@RestController` combine `@Controller` et `@ResponseBody`, indiquant que la classe gère des requêtes HTTP REST et que les méthodes renvoient directement des données JSON ou XML plutôt qu’une vue.",
          "keyWords": ["@RestController", "Controller", "ResponseBody", "HTTP REST", "JSON", "XML", "méthodes", "données"]
        },
        {
          "question": "Qu'est-ce qu'un Bean dans Spring ?",
          "textResponse": "Un Bean est un objet géré par le conteneur Spring, instancié, configuré et injecté automatiquement selon les annotations ou la configuration XML, permettant l’inversion de contrôle et la réutilisabilité des composants.",
          "keyWords": ["Bean", "Spring", "objet", "conteneur", "instancié", "configuré", "injection", "annotations", "inversion de contrôle", "réutilisabilité"]
        },
        {
          "question": "Expliquez l'injection de dépendances.",
          "textResponse": "L’injection de dépendances est un principe où le conteneur Spring fournit automatiquement les objets requis à une classe, au lieu de créer manuellement les instances, favorisant le couplage faible et la testabilité.",
          "keyWords": ["injection de dépendances", "Spring", "conteneur", "objets", "instances", "couplage faible", "testabilité"]
        },
        {
          "question": "Quelle annotation est utilisée pour injecter un Bean ?",
          "textResponse": "L’annotation `@Autowired` est utilisée pour injecter automatiquement un Bean dans un autre composant Spring, permettant au conteneur de gérer les dépendances sans instanciation manuelle.",
          "keyWords": ["@Autowired", "Bean", "Spring", "injection", "composant", "conteneur", "dépendances", "automatique"]
        },
        {
          "question": "Qu'est-ce que le Spring Boot Actuator ?",
          "textResponse": "Spring Boot Actuator fournit des endpoints prêts à l’emploi pour surveiller et gérer une application, offrant des informations sur la santé, les métriques, les logs et les beans, facilitant l’observabilité.",
          "keyWords": ["Spring Boot Actuator", "endpoints", "surveillance", "gestion", "application", "santé", "métriques", "logs", "beans", "observabilité"]
        },
        {
          "question": "À quoi sert le fichier `pom.xml` dans un projet Spring Boot Maven ?",
          "textResponse": "Le fichier `pom.xml` définit les dépendances, plugins et configurations Maven pour construire, compiler et exécuter un projet Spring Boot, gérant les versions et les librairies nécessaires.",
          "keyWords": ["pom.xml", "Maven", "dépendances", "plugins", "configuration", "construction", "compilation", "Spring Boot", "librairies", "versions"]
        },
        {
          "question": "Comment configurer une connexion à une base de données dans Spring Boot ?",
          "textResponse": "Une connexion à une base de données se configure dans `application.properties` ou `application.yml` avec l’URL, le driver, le nom d’utilisateur et le mot de passe, et peut être combinée avec Spring Data JPA pour simplifier les opérations CRUD.",
          "keyWords": ["connexion", "base de données", "Spring Boot", "application.properties", "application.yml", "URL", "driver", "Spring Data JPA", "CRUD"]
        },
        {
          "question": "Qu'est-ce que le profiling dans Spring Boot ?",
          "textResponse": "Le profiling dans Spring Boot permet de définir différents environnements (dev, test, prod) avec des configurations spécifiques, activables via le profil actif, facilitant la gestion des paramètres selon le contexte.",
          "keyWords": ["profiling", "Spring Boot", "environnements", "dev", "test", "prod", "configuration", "profil actif", "gestion", "paramètres"]
        },
        {
          "question": "Comment définir un profil actif dans Spring Boot ?",
          "textResponse": "Le profil actif peut être défini via `application.properties` avec `spring.profiles.active` ou par des arguments de ligne de commande, permettant de charger les configurations spécifiques à un environnement.",
          "keyWords": ["profil actif", "Spring Boot", "application.properties", "spring.profiles.active", "ligne de commande", "configurations", "environnement"]
        },
        {
          "question": "Expliquez l'annotation `@Value`.",
          "textResponse": "L’annotation `@Value` permet d’injecter des valeurs provenant de fichiers de configuration, variables d’environnement ou expressions dans les champs d’un Bean, facilitant la gestion des paramètres dynamiques.",
          "keyWords": ["@Value", "injection", "valeurs", "configuration", "variables d’environnement", "expressions", "Bean", "paramètres dynamiques"]
        },
        {
          "question": "À quoi sert l'annotation `@Autowired` ?",
          "textResponse": "`@Autowired` est utilisée pour que Spring injecte automatiquement les dépendances d’un Bean dans un autre, réduisant la configuration manuelle et favorisant le couplage faible.",
          "keyWords": ["@Autowired", "Spring", "injection", "dépendances", "Bean", "configuration manuelle", "couplage faible"]
        },
        {
          "question": "Qu'est-ce que Spring Initializr ?",
          "textResponse": "Spring Initializr est un outil web qui génère des projets Spring Boot prêts à l’emploi, permettant de sélectionner le type de projet, la version de Spring Boot, les dépendances et la structure du projet.",
          "keyWords": ["Spring Initializr", "outil", "projets", "Spring Boot", "dépendances", "structure", "type de projet", "version"]
        },
        {
          "question": "Comment définir un endpoint REST dans Spring Boot ?",
          "textResponse": "Un endpoint REST est défini avec `@RestController` et des annotations de mapping comme `@GetMapping`, `@PostMapping`, `@PutMapping` ou `@DeleteMapping`, en précisant l’URL et la méthode de traitement correspondante.",
          "keyWords": ["endpoint REST", "Spring Boot", "@RestController", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "URL", "méthode"]
        },
        {
          "question": "Qu'est-ce que l'IoC (Inversion of Control) en Spring ?",
          "textResponse": "L'IoC est un principe où le contrôle de la création et de la gestion des objets est délégué au conteneur Spring plutôt que géré manuellement dans le code. Spring crée, configure et injecte les beans automatiquement.",
          "keyWords": ["IoC", "Inversion of Control", "Spring", "beans", "injection"]
        },

        {
          "question": "Quelle est la différence entre `@Component`, `@Service` et `@Repository` ?",
          "textResponse": "`@Component` est générique pour tous les Beans, `@Service` est spécifique aux services métiers, et `@Repository` pour les composants d’accès aux données avec gestion des exceptions liées à la persistance.",
          "keyWords": ["@Component", "@Service", "@Repository", "Bean", "services métiers", "données", "persistance", "exceptions"]
        },

        {
          "question": "Qu'est-ce que @Component en Spring ?",
          "textResponse": "@Component est une annotation générique utilisée pour marquer une classe comme un bean Spring géré par le conteneur IoC.",
          "keyWords": ["@Component", "bean", "Spring", "IoC"]
        },
        {
          "question": "Qu'est-ce que @Service en Spring ?",
          "textResponse": "@Service est une spécialisation de @Component utilisée pour marquer une classe qui contient la logique métier (service layer).",
          "keyWords": ["@Service", "logique métier", "service layer", "Spring"]
        },
        {
          "question": "Qu'est-ce que @Repository en Spring ?",
          "textResponse": "@Repository est une spécialisation de @Component utilisée pour les classes d'accès aux données (DAO). Elle active aussi la traduction automatique des exceptions liées à la base de données.",
          "keyWords": ["@Repository", "DAO", "accès aux données", "exceptions"]
        },
        {
          "question": "Qu'est-ce que @Configuration en Spring ?",
          "textResponse": "@Configuration est une annotation qui indique qu'une classe contient des définitions de beans. Elle est souvent utilisée avec @Bean pour configurer l'application.",
          "keyWords": ["@Configuration", "beans", "configuration", "@Bean"]
        }

        ,

        {
          "question": "Quels sont les scopes possibles pour un bean Spring ?",
          "textResponse": "Spring propose plusieurs scopes :\n- singleton : une seule instance pour toute l'application (par défaut)\n- prototype : nouvelle instance à chaque demande\n- request : une instance par requête HTTP\n- session : une instance par session HTTP\n- application : une instance pour toute l'application web\n- websocket : une instance par session WebSocket",
          "keyWords": ["singleton", "prototype", "request", "session", "application", "websocket", "scope", "Spring"]
        },


        {
          "question": "Que fait l'annotation `@RequestMapping` et ses variantes ?",
          "textResponse": "`@RequestMapping` mappe une URL à une méthode d’un contrôleur, tandis que ses variantes (`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`) sont des raccourcis spécifiques pour chaque type de requête HTTP.",
          "keyWords": ["@RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "URL", "contrôleur", "requête HTTP"]
        },
        {
          "question": "Comment gérer les exceptions dans Spring Boot ?",
          "textResponse": "Les exceptions peuvent être gérées avec `@ExceptionHandler` dans un contrôleur ou via `@ControllerAdvice` pour un traitement global, permettant de renvoyer des réponses personnalisées et de maintenir la robustesse de l’application.",
          "keyWords": ["exceptions", "Spring Boot", "@ExceptionHandler", "@ControllerAdvice", "réponses personnalisées", "robustesse", "application"]
        },
        {
          "question": "Qu'est-ce que le Spring Data JPA ?",
          "textResponse": "Spring Data JPA est un module qui simplifie l’accès aux bases de données relationnelles en fournissant des interfaces Repository, des méthodes CRUD automatiques et le mapping entre entités Java et tables SQL.",
          "keyWords": ["Spring Data JPA", "bases de données", "relationnelles", "Repository", "CRUD", "mapping", "entités", "tables SQL"]
        },
        {
          "question": "Comment créer un Repository avec Spring Data JPA ?",
          "textResponse": "Un Repository est créé en étendant des interfaces comme `JpaRepository` ou `CrudRepository`, ce qui fournit automatiquement les méthodes CRUD et permet d’ajouter des requêtes personnalisées avec des annotations ou des noms de méthodes.",
          "keyWords": ["Repository", "Spring Data JPA", "JpaRepository", "CrudRepository", "CRUD", "requêtes personnalisées", "annotations"]
        },
        {
          "question": "Quelle est la différence entre `CrudRepository` et `JpaRepository` ?",
          "textResponse": "`CrudRepository` fournit les opérations CRUD de base, tandis que `JpaRepository` hérite de `CrudRepository` et ajoute des fonctionnalités avancées comme le pagination, le tri et les méthodes spécifiques à JPA.",
          "keyWords": ["CrudRepository", "JpaRepository", "CRUD", "pagination", "tri", "JPA", "fonctionnalités avancées"]
        },
        {
          "question": "Comment sécuriser une application Spring Boot ?",
          "textResponse": "Une application Spring Boot peut être sécurisée avec Spring Security en configurant l’authentification, l’autorisation, le chiffrement des mots de passe, la protection CSRF, les rôles utilisateurs et les filtres personnalisés.",
          "keyWords": ["sécurité", "Spring Boot", "Spring Security", "authentification", "autorisation", "chiffrement", "mots de passe", "CSRF", "rôles", "filtres"]
        },
        {
          "question": "Qu'est-ce que Spring Security ?",
          "textResponse": "Spring Security est un framework fournissant des mécanismes d’authentification et d’autorisation pour les applications Java, avec intégration facile dans Spring Boot et support des standards comme OAuth2 et JWT.",
          "keyWords": ["Spring Security", "authentification", "autorisation", "Java", "Spring Boot", "OAuth2", "JWT", "framework"]
        },
        {
          "question": "Qu'est-ce que l'injection par constructeur ?",
          "textResponse": "L’injection par constructeur consiste à fournir les dépendances nécessaires à un Bean via son constructeur, garantissant que le Bean est complètement initialisé dès sa création et favorisant l’immuabilité et le couplage faible.",
          "keyWords": ["injection", "constructeur", "Bean", "dépendances", "initialisation", "immuabilité", "couplage faible"]
        },
        {
          "question": "Expliquez la portée des Beans : singleton, prototype.",
          "textResponse": "Un Bean singleton est unique dans le conteneur Spring et partagé entre toutes les requêtes, tandis qu’un Bean prototype crée une nouvelle instance à chaque injection, offrant un comportement par-instance.",
          "keyWords": ["Beans", "portée", "singleton", "prototype", "conteneur", "injection", "instance", "comportement"]
        },
        {
          "question": "Qu'est-ce qu'un middleware dans Spring Boot ?",
          "textResponse": "Un middleware dans Spring Boot est un composant intermédiaire qui intercepte les requêtes et réponses HTTP pour appliquer des traitements transversaux comme la journalisation, la sécurité ou la gestion des exceptions.",
          "keyWords": ["middleware", "Spring Boot", "requêtes", "réponses HTTP", "journalisation", "sécurité", "exceptions", "composant"]
        },
        {
          "question": "Que fait `@Bean` ?",
          "textResponse": "L’annotation `@Bean` indique à Spring de créer et gérer un objet spécifique comme Bean dans le conteneur, permettant son injection dans d’autres composants de l’application.",
          "keyWords": ["@Bean", "Spring", "création", "gestion", "objet", "conteneur", "injection", "composants"]
        },
        {
          "question": "Comment gérer les propriétés personnalisées dans Spring Boot ?",
          "textResponse": "Les propriétés personnalisées peuvent être définies dans `application.properties` ou `application.yml` et injectées dans les Beans avec `@Value` ou des classes de configuration annotées `@ConfigurationProperties` pour un mapping automatique.",
          "keyWords": ["propriétés personnalisées", "Spring Boot", "application.properties", "application.yml", "@Value", "@ConfigurationProperties", "mapping", "Beans"]
        },
        {
          "question": "À quoi sert l’annotation `@ComponentScan` ?",
          "textResponse": "`@ComponentScan` indique à Spring où rechercher les classes annotées pour les enregistrer comme Beans dans le conteneur, facilitant la découverte automatique des composants.",
          "keyWords": ["@ComponentScan", "Spring", "recherche", "classes", "annotations", "Beans", "conteneur", "découverte"]
        },
        {
          "question": "Qu’est-ce que le CORS et comment le gérer dans Spring Boot ?",
          "textResponse": "Le CORS (Cross-Origin Resource Sharing) est une politique de sécurité contrôlant les requêtes entre domaines. Dans Spring Boot, il peut être géré via `@CrossOrigin` sur les contrôleurs ou une configuration globale via `WebMvcConfigurer`.",
          "keyWords": ["CORS", "Cross-Origin Resource Sharing", "sécurité", "Spring Boot", "@CrossOrigin", "WebMvcConfigurer", "contrôleurs"]
        },
        {
          "question": "Comment configurer la pagination avec Spring Data JPA ?",
          "textResponse": "La pagination est configurée en utilisant les objets `Pageable` et `Page` dans les méthodes des Repository, permettant de récupérer des sous-ensembles de données avec taille et page définies, et de trier les résultats.",
          "keyWords": ["pagination", "Spring Data JPA", "Pageable", "Page", "Repository", "données", "taille", "page", "tri"]
        },
        {
          "question": "Qu'est-ce que la sérialisation JSON dans Spring Boot ?",
          "textResponse": "La sérialisation JSON convertit des objets Java en format JSON pour l’envoi dans les réponses HTTP, et Spring Boot utilise par défaut Jackson pour gérer automatiquement cette conversion.",
          "keyWords": ["sérialisation JSON", "Spring Boot", "objets Java", "format JSON", "réponses HTTP", "Jackson", "conversion"]
        }
      ]
    },
    {
      "topic": "Spring Data JPA",
      "questions": [
        {
          "question": "Qu'est-ce que JPA (Java Persistence API) ?",
          "textResponse": "JPA est une spécification Java qui standardise la gestion de la persistance des objets dans les bases de données relationnelles, offrant des abstractions pour le mapping objet-relationnel, les entités et les opérations CRUD.",
          "keyWords": ["JPA", "Java Persistence API", "persistence", "bases de données relationnelles", "mapping objet-relationnel", "entités", "CRUD"]
        },
        {
          "question": "JPA vs Spring Data JPA ?",
          "textResponse": "JPA (Java Persistence API) est une spécification standard pour gérer la persistance des objets Java dans des bases relationnelles, nécessitant une implémentation comme Hibernate pour fonctionner. Spring Data JPA est une surcouche qui simplifie l'utilisation de JPA dans les projets Spring Boot en fournissant des interfaces Repository, CRUD automatique, query methods, pagination, tri et intégration transparente avec Spring, réduisant le code boilerplate et améliorant la productivité.",
          "keyWords": ["JPA", "Java Persistence API", "Spring Data JPA", "Hibernate", "Repository", "CRUD", "query methods", "pagination", "tri", "Spring Boot", "productivité", "code boilerplate"]
        },

        {
          "question": "Quelle est la différence entre JPA et Hibernate ?",
          "textResponse": "JPA est une spécification standard, tandis qu’Hibernate est une implémentation concrète de JPA, offrant des fonctionnalités supplémentaires comme le caching avancé, les types spécifiques et les stratégies de fetching.",
          "keyWords": ["JPA", "Hibernate", "spécification", "implémentation", "caching", "fetching", "types spécifiques"]
        },
        {
          "question": "Quel est le rôle de Spring Data JPA dans un projet Spring Boot ?",
          "textResponse": "Spring Data JPA simplifie l’accès aux données dans Spring Boot en fournissant des interfaces Repository, des méthodes CRUD automatiques et la possibilité de créer des requêtes dérivées sans écrire de SQL.",
          "keyWords": ["Spring Data JPA", "Spring Boot", "Repository", "CRUD", "requêtes dérivées", "SQL", "accès aux données"]
        },
        {
          "question": "Qu'est-ce qu'une entité JPA ?",
          "textResponse": "Une entité JPA est une classe Java annotée avec `@Entity` représentant une table dans une base de données relationnelle, avec des champs mappés aux colonnes et un identifiant unique pour chaque instance.",
          "keyWords": ["entité JPA", "classe Java", "@Entity", "table", "base de données relationnelle", "champs", "colonnes", "identifiant"]
        },
        {
          "question": "Quelle est l'utilité de l'annotation @Entity ?",
          "textResponse": "@Entity indique à JPA que la classe est persistable et doit être mappée à une table dans la base de données, permettant au conteneur de gérer ses instances et leur cycle de vie.",
          "keyWords": ["@Entity", "JPA", "persistable", "table", "base de données", "cycle de vie"]
        },
        {
          "question": "Quelle annotation permet de définir la clé primaire dans une entité JPA ?",
          "textResponse": "L’annotation `@Id` définit le champ représentant la clé primaire de l’entité, et peut être combinée avec `@GeneratedValue` pour automatiser la génération de l’identifiant.",
          "keyWords": ["@Id", "clé primaire", "entité JPA", "@GeneratedValue", "identifiant"]
        },
        {
          "question": "Qu'est-ce que l'EntityManager en JPA ?",
          "textResponse": "L'EntityManager est l’interface principale de JPA qui gère le cycle de vie des entités, permet les opérations CRUD, les requêtes JPQL et le contrôle des transactions.",
          "keyWords": ["EntityManager", "JPA", "cycle de vie", "entités", "CRUD", "JPQL", "transactions"]
        },
        {
          "question": "Quelle est la différence entre persist() et merge() en JPA ?",
          "textResponse": "`persist()` rend une entité managée et l’insère dans la base, tandis que `merge()` synchronise l’état d’une entité détachée avec la base de données, créant ou mettant à jour l’enregistrement.",
          "keyWords": ["persist()", "merge()", "JPA", "entité managée", "entité détachée", "base de données", "insertion", "mise à jour"]
        },
        {
          "question": "Qu'est-ce que le Repository dans Spring Data JPA ?",
          "textResponse": "Un Repository est une interface dans Spring Data JPA qui encapsule l’accès aux données, offrant des méthodes CRUD automatiques et la possibilité de définir des requêtes dérivées ou personnalisées.",
          "keyWords": ["Repository", "Spring Data JPA", "interface", "accès aux données", "CRUD", "requêtes dérivées", "requêtes personnalisées"]
        },
        {
          "question": "Quelle est la différence entre CrudRepository et JpaRepository ?",
          "textResponse": "CrudRepository fournit les opérations CRUD de base, tandis que JpaRepository étend CrudRepository et ajoute des fonctionnalités avancées comme le tri, la pagination et le batch processing.",
          "keyWords": ["CrudRepository", "JpaRepository", "CRUD", "tri", "pagination", "batch processing", "Spring Data JPA"]
        },
        {
          "question": "Comment créer un repository personnalisé dans Spring Data JPA ?",
          "textResponse": "Un repository personnalisé se crée en étendant l’interface Repository ou JpaRepository et en ajoutant des méthodes spécifiques, ou en implémentant une interface personnalisée avec des méthodes et la logique correspondante.",
          "keyWords": ["repository personnalisé", "Spring Data JPA", "Repository", "JpaRepository", "méthodes spécifiques", "implémentation"]
        },
        {
          "question": "Comment effectuer une requête avec Spring Data JPA sans écrire de SQL ?",
          "textResponse": "Spring Data JPA permet d’effectuer des requêtes sans SQL en utilisant les query methods (méthodes dérivées), où le nom de la méthode définit la requête automatiquement en fonction des champs de l’entité.",
          "keyWords": ["Spring Data JPA", "requête", "query methods", "méthodes dérivées", "nom de méthode", "entité"]
        },
        {
          "question": "Qu'est-ce que JPQL et en quoi diffère-t-il du SQL classique ?",
          "textResponse": "JPQL (Java Persistence Query Language) est un langage de requêtes orienté objet pour JPA, similaire à SQL mais opérant sur des entités et leurs relations plutôt que sur des tables et colonnes physiques.",
          "keyWords": ["JPQL", "Java Persistence Query Language", "JPA", "requêtes", "orienté objet", "entités", "relations", "SQL"]
        },
        {
          "question": "Que sont les méthodes dérivées (query methods) dans Spring Data JPA ?",
          "textResponse": "Les query methods sont des méthodes de repository dont le nom définit la requête automatiquement, permettant de récupérer des entités selon des critères sans écrire de JPQL ou SQL.",
          "keyWords": ["query methods", "Spring Data JPA", "repository", "nom de méthode", "requête automatique", "entités", "JPQL", "SQL"]
        },
        {
          "question": "Comment gérer les relations entre entités avec JPA (ex : OneToMany, ManyToOne) ?",
          "textResponse": "Les relations entre entités se définissent via des annotations comme `@OneToMany`, `@ManyToOne`, `@OneToOne` et `@ManyToMany`, avec des attributs pour le mapping, la cascade et le fetch, permettant de naviguer entre les entités liées.",
          "keyWords": ["relations", "entités", "JPA", "@OneToMany", "@ManyToOne", "@OneToOne", "@ManyToMany", "mapping", "cascade", "fetch"]
        },
        {
          "question": "Qu'est-ce que la pagination et le tri dans Spring Data JPA ?",
          "textResponse": "La pagination et le tri permettent de limiter et d’ordonner les résultats d’une requête en utilisant les objets `Pageable` et `Sort`, réduisant la mémoire utilisée et améliorant la performance des requêtes.",
          "keyWords": ["pagination", "tri", "Spring Data JPA", "Pageable", "Sort", "résultats", "requêtes", "performance"]
        },
        {
          "question": "Quelle annotation permet de définir une transaction dans Spring Data JPA ?",
          "textResponse": "L’annotation `@Transactional` permet de définir le contexte transactionnel d’une méthode ou classe dans Spring Data JPA, assurant commit ou rollback automatique des opérations.",
          "keyWords": ["@Transactional", "Spring Data JPA", "transaction", "méthode", "classe", "commit", "rollback"]
        },
        {
          "question": "Comment écrire une requête personnalisée avec l'annotation @Query ?",
          "textResponse": "L’annotation `@Query` permet de définir une requête JPQL ou SQL native directement sur une méthode de repository, offrant un contrôle précis sur la récupération des données.",
          "keyWords": ["@Query", "Spring Data JPA", "requête personnalisée", "JPQL", "SQL native", "repository"]
        },
        {
          "question": "Comment gérer les exceptions liées à la persistance dans Spring Data JPA ?",
          "textResponse": "Les exceptions liées à la persistance sont capturées par Spring Data JPA et peuvent être traitées via `@ExceptionHandler` ou en interceptant les exceptions de type `DataAccessException`, garantissant un comportement cohérent de l’application.",
          "keyWords": ["exceptions", "persistance", "Spring Data JPA", "@ExceptionHandler", "DataAccessException", "traitement", "application"]
        },
        {
          "question": "Qu’est-ce que le Lazy Loading et comment fonctionne-t-il dans JPA ?",
          "textResponse": "Le Lazy Loading est une stratégie où les relations ou collections d’entités ne sont chargées que lorsqu’elles sont accédées, réduisant le coût en mémoire et optimisant les performances, contrairement à l’Eager Loading qui charge tout immédiatement.",
          "keyWords": ["Lazy Loading", "JPA", "relations", "collections", "chargement différé", "mémoire", "performances", "Eager Loading"]
        },
        {
          "question": "Quelle est la différence entre Lazy Loading et Eager Loading ?",
          "textResponse": "Lazy Loading charge les entités liées uniquement à la demande, tandis qu’Eager Loading les charge immédiatement lors de la récupération de l’entité principale, impactant la mémoire et les performances.",
          "keyWords": ["Lazy Loading", "Eager Loading", "JPA", "entités liées", "chargement différé", "mémoire", "performances"]
        },
        {
          "question": "Comment fonctionne le cache de premier niveau (cache de session) en JPA ?",
          "textResponse": "Le cache de premier niveau est associé à l’EntityManager et stocke les entités managées pendant la session, évitant des requêtes répétitives vers la base de données pour les mêmes objets.",
          "keyWords": ["cache premier niveau", "JPA", "EntityManager", "entités managées", "session", "requêtes", "base de données"]
        },
        {
          "question": "Qu’est-ce que le cache de second niveau dans JPA, et comment le configurer ?",
          "textResponse": "Le cache de second niveau est partagé entre les EntityManagers et peut être configuré via des providers comme Ehcache ou Hazelcast, permettant de stocker des entités fréquemment utilisées et d’améliorer les performances.",
          "keyWords": ["cache second niveau", "JPA", "EntityManager", "Ehcache", "Hazelcast", "entités", "performances"]
        },
        {
          "question": "Quelle est la différence entre flush() et commit() dans EntityManager ?",
          "textResponse": "`flush()` synchronise l’état des entités managées avec la base de données sans terminer la transaction, tandis que `commit()` valide la transaction et rend permanentes toutes les modifications.",
          "keyWords": ["flush()", "commit()", "EntityManager", "synchronisation", "entités managées", "base de données", "transaction"]
        },
        {
          "question": "Comment gérer les transactions déclaratives avec Spring et JPA ?",
          "textResponse": "Les transactions déclaratives se configurent via `@Transactional` sur les méthodes ou classes, laissant Spring gérer automatiquement le commit et le rollback sans code explicite de gestion transactionnelle.",
          "keyWords": ["transactions déclaratives", "Spring", "JPA", "@Transactional", "commit", "rollback", "gestion automatique"]
        },
        {
          "question": "Comment faire la pagination efficace des résultats dans Spring Data JPA ?",
          "textResponse": "La pagination efficace se fait en utilisant `Pageable` dans les méthodes de repository, combinée à des index et un tri approprié pour limiter la mémoire et réduire le nombre de résultats renvoyés par requête.",
          "keyWords": ["pagination", "Spring Data JPA", "Pageable", "repository", "index", "tri", "mémoire", "résultats"]
        },
        {
          "question": "Comment écrire des requêtes avec des jointures complexes en JPQL ?",
          "textResponse": "Les requêtes avec jointures complexes se construisent en JPQL en utilisant `JOIN`, `LEFT JOIN`, `FETCH JOIN` et en naviguant sur les relations d’entités pour combiner les données de plusieurs tables.",
          "keyWords": ["JPQL", "requêtes", "jointures", "JOIN", "LEFT JOIN", "FETCH JOIN", "relations", "entités"]
        },
        {
          "question": "Comment optimiser les performances avec Spring Data JPA ?",
          "textResponse": "L’optimisation se fait via l’utilisation de fetch strategies appropriées, le caching, la pagination, l’évitement des N+1 queries, et la rédaction de requêtes JPQL ou SQL natives performantes.",
          "keyWords": ["optimisation", "Spring Data JPA", "fetch strategies", "caching", "pagination", "N+1 queries", "JPQL", "SQL"]
        },
        {
          "question": "Comment intégrer Spring Data JPA avec des bases de données multiples ?",
          "textResponse": "On configure plusieurs `DataSource`, `EntityManagerFactory` et `TransactionManager`, et on associe chaque repository à la source de données appropriée via `@EnableJpaRepositories(basePackages=...)`.",
          "keyWords": ["Spring Data JPA", "bases de données multiples", "DataSource", "EntityManagerFactory", "TransactionManager", "repository", "@EnableJpaRepositories"]
        },
        {
          "question": "Comment fonctionne le système de locking optimiste et pessimiste en JPA ?",
          "textResponse": "Le locking optimiste utilise une version de l’entité pour détecter les conflits de modification, tandis que le locking pessimiste verrouille la ligne en base pour empêcher d’autres transactions de la modifier simultanément.",
          "keyWords": ["locking", "optimiste", "pessimiste", "JPA", "version", "conflits", "transactions", "verrou"]
        },
        {
          "question": "Quelles sont les bonnes pratiques pour gérer les mises à jour massives avec Spring Data JPA ?",
          "textResponse": "Pour les mises à jour massives, il est recommandé d’utiliser des requêtes JPQL ou SQL natives, de batcher les opérations, de gérer le flush et clear de l’EntityManager et d’éviter le chargement inutile des entités.",
          "keyWords": ["mises à jour massives", "Spring Data JPA", "JPQL", "SQL", "batch", "flush", "clear", "EntityManager", "performances"]
        },
        {
          "question": "Comment personnaliser la génération des identifiants dans JPA ?",
          "textResponse": "La génération des identifiants se personnalise avec `@GeneratedValue` et ses stratégies (`IDENTITY`, `SEQUENCE`, `TABLE`, `AUTO`), permettant de contrôler le type et la source de l’ID.",
          "keyWords": ["identifiants", "JPA", "@GeneratedValue", "IDENTITY", "SEQUENCE", "TABLE", "AUTO", "ID"]
        },
        {
          "question": "Quelle différence entre @MappedSuperclass, @Entity et @Embeddable ?",
          "textResponse": "@MappedSuperclass définit une classe parente dont les champs sont hérités par les entités, @Entity représente une table persistable, et @Embeddable définit un objet réutilisable intégré dans une entité.",
          "keyWords": ["@MappedSuperclass", "@Entity", "@Embeddable", "JPA", "classe parente", "héritage", "table", "persistable", "objet réutilisable"]
        },
        {
          "question": "Comment fonctionne la gestion du cycle de vie d’une entité dans JPA ?",
          "textResponse": "Le cycle de vie inclut les états transient, managed, detached et removed. Les callbacks `@PrePersist`, `@PostPersist`, `@PreUpdate`, `@PostUpdate`, `@PreRemove`, `@PostRemove`, `@PostLoad` permettent d’exécuter du code à chaque transition.",
          "keyWords": ["cycle de vie", "JPA", "transient", "managed", "detached", "removed", "@PrePersist", "@PostPersist", "@PreUpdate", "@PostUpdate", "@PreRemove", "@PostRemove", "@PostLoad"]
        },
        {
          "question": "Qu’est-ce que le DTO Projection dans Spring Data JPA ?",
          "textResponse": "Le DTO Projection permet de récupérer uniquement certaines colonnes d’une entité ou de combiner plusieurs entités dans un objet personnalisé, réduisant la quantité de données transférées et optimisant la performance.",
          "keyWords": ["DTO Projection", "Spring Data JPA", "colonnes", "entité", "objet personnalisé", "performance", "données"]
        },
        {
          "question": "Comment utiliser Specifications et Criteria API avec Spring Data JPA ?",
          "textResponse": "Les Specifications et Criteria API permettent de construire dynamiquement des requêtes typées et complexes de manière programmatique, offrant flexibilité et sécurité de type pour filtrer les entités.",
          "keyWords": ["Specifications", "Criteria API", "Spring Data JPA", "requêtes dynamiques", "typées", "filtrage", "entités"]
        },
        {
          "question": "Qu'est-ce que Spring Data Auditing et comment l'activer ?",
          "textResponse": "Spring Data Auditing permet de suivre automatiquement la création et la modification des entités via des annotations comme `@CreatedDate`, `@LastModifiedDate`, `@CreatedBy` et `@LastModifiedBy`, activé avec `@EnableJpaAuditing`.",
          "keyWords": ["Spring Data Auditing", "entités", "création", "modification", "@CreatedDate", "@LastModifiedDate", "@CreatedBy", "@LastModifiedBy", "@EnableJpaAuditing"]
        },
        {
          "question": "Comment écrire un repository asynchrone avec Spring Data JPA ?",
          "textResponse": "Un repository asynchrone utilise des méthodes retournant `CompletableFuture`, `ListenableFuture` ou `Future`, permettant l’exécution non bloquante des requêtes et une meilleure réactivité de l’application.",
          "keyWords": ["repository asynchrone", "Spring Data JPA", "CompletableFuture", "ListenableFuture", "Future", "non bloquant", "réactivité"]
        },
        {
          "question": "Comment fonctionne la gestion des entités détachées (detached entities) ?",
          "textResponse": "Une entité détachée n’est plus gérée par l’EntityManager. Pour la persister ou la synchroniser avec la base, on utilise `merge()`, tandis que les modifications directes sur des entités détachées ne sont pas automatiquement reflétées.",
          "keyWords": ["entités détachées", "JPA", "EntityManager", "merge()", "synchronisation", "modifications"]
        },
        {
          "question": "Comment gérer la concurrency dans les applications avec Spring Data JPA ?",
          "textResponse": "La concurrency se gère via les stratégies de locking optimiste ou pessimiste, les transactions appropriées et le versioning des entités, garantissant l’intégrité des données dans les scénarios multi-utilisateurs.",
          "keyWords": ["concurrency", "Spring Data JPA", "locking", "optimiste", "pessimiste", "transactions", "versioning", "intégrité"]
        }
      ]

    },
    {
      "topic": "DevOps",
      "questions": [
        {
          "question": "Qu’est-ce que DevOps ?",
          "textResponse": "DevOps est une culture et un ensemble de pratiques qui visent à rapprocher les équipes de développement et d’exploitation pour automatiser, surveiller et améliorer le cycle de vie des applications, favorisant ainsi la rapidité et la qualité des livraisons.",
          "keyWords": ["DevOps", "culture", "pratiques", "développement", "exploitation", "automatisation", "surveillance", "cycle de vie", "applications", "livraisons"]
        },
        {
          "question": "Quelle est la différence entre DevOps et Agile ?",
          "textResponse": "Agile est une méthodologie de développement qui se concentre sur des itérations rapides et la collaboration dans l’équipe de développement, tandis que DevOps étend ces principes à l’exploitation, en automatisant le déploiement et la surveillance pour une livraison continue.",
          "keyWords": ["Agile", "DevOps", "méthodologie", "itérations", "collaboration", "développement", "exploitation", "automatisation", "déploiement", "livraison continue"]
        },
        {
          "question": "Quels sont les objectifs principaux de DevOps ?",
          "textResponse": "Les objectifs de DevOps incluent l’accélération des livraisons, l’amélioration de la qualité du code, la réduction des erreurs de production, l’automatisation des processus et la collaboration efficace entre développement et opérations.",
          "keyWords": ["DevOps", "accélération", "livraisons", "qualité du code", "erreurs de production", "automatisation", "collaboration", "développement", "opérations"]
        },
        {
          "question": "Qu’est-ce que l’intégration continue (CI) ?",
          "textResponse": "L’intégration continue (CI) est une pratique DevOps qui consiste à intégrer fréquemment le code dans le dépôt principal, avec des builds et tests automatiques, permettant de détecter rapidement les erreurs et d’améliorer la qualité du logiciel.",
          "keyWords": ["intégration continue", "CI", "DevOps", "dépôt", "builds automatiques", "tests", "erreurs", "qualité", "logiciel"]
        },
        {
          "question": "Qu’est-ce que le déploiement continu (CD) ?",
          "textResponse": "Le déploiement continu (CD) est une pratique qui permet de livrer automatiquement le code validé en production ou sur des environnements de test, réduisant le temps entre développement et mise en production.",
          "keyWords": ["déploiement continu", "CD", "livraison automatique", "production", "environnement de test", "temps", "développement"]
        },
        {
          "question": "Qu’est-ce qu’un pipeline CI/CD ?",
          "textResponse": "Un pipeline CI/CD est un enchaînement automatisé d’étapes incluant la compilation, les tests, l’intégration et le déploiement du code, permettant de garantir des livraisons fiables et rapides.",
          "keyWords": ["pipeline", "CI/CD", "automatisation", "compilation", "tests", "intégration", "déploiement", "livraisons", "fiables"]
        },
        {
          "question": "Quelle est l’importance de l’automatisation dans DevOps ?",
          "textResponse": "L’automatisation dans DevOps réduit les erreurs humaines, accélère le cycle de développement, standardise les processus, facilite le déploiement et permet un retour d’information rapide sur la qualité du code.",
          "keyWords": ["automatisation", "DevOps", "réduction erreurs", "cycle de développement", "standardisation", "déploiement", "feedback", "qualité du code"]
        },
        {
          "question": "Qu’est-ce qu’un repository Git ?",
          "textResponse": "Un repository Git est un espace de stockage pour un projet de code source où sont conservées toutes les versions, permettant de gérer les modifications, collaborer avec d’autres développeurs et revenir à des versions précédentes si nécessaire.",
          "keyWords": ["repository", "Git", "projet", "code source", "versions", "modifications", "collaboration", "historique"]
        },
        {
          "question": "Quelle est la différence entre Git et SVN ?",
          "textResponse": "Git est un système de contrôle de version distribué où chaque développeur a une copie complète du dépôt, tandis que SVN est centralisé et nécessite un accès au serveur pour obtenir les modifications, Git offrant plus de flexibilité et de rapidité.",
          "keyWords": ["Git", "SVN", "contrôle de version", "distribué", "centralisé", "serveur", "flexibilité", "rapidité"]
        },
        {
          "question": "Qu’est-ce qu’un commit dans Git ?",
          "textResponse": "Un commit dans Git est une action qui enregistre un ensemble de modifications dans le repository, avec un message décrivant les changements, permettant de créer un historique clair et traçable du code.",
          "keyWords": ["commit", "Git", "modifications", "repository", "message", "historique", "traçable"]
        },
        {
          "question": "Que signifie « merge » dans Git ?",
          "textResponse": "Le merge dans Git consiste à combiner les modifications de deux branches distinctes pour les intégrer dans une branche cible, résolvant automatiquement ou manuellement les conflits éventuels.",
          "keyWords": ["merge", "Git", "branches", "combinaison", "intégration", "conflits"]
        },
        {
          "question": "Qu’est-ce qu’une branche dans Git ?",
          "textResponse": "Une branche dans Git est une version parallèle du code source qui permet de développer des fonctionnalités ou corrections indépendamment de la branche principale, facilitant le travail collaboratif et le contrôle des versions.",
          "keyWords": ["branche", "Git", "version parallèle", "fonctionnalités", "corrections", "collaboration", "contrôle des versions"]
        },
        {
          "question": "Que fait la commande `git pull` ?",
          "textResponse": "La commande `git pull` récupère les modifications d’un dépôt distant et les fusionne avec la branche locale, mettant à jour le code tout en intégrant les contributions des autres développeurs.",
          "keyWords": ["git pull", "Git", "dépôt distant", "fusion", "branche locale", "mise à jour", "contributions"]
        },
        {
          "question": "Qu’est-ce qu’un « rollback » en DevOps ?",
          "textResponse": "Un rollback est le processus de restauration d’une version précédente d’une application ou d’un service après une erreur ou un échec de déploiement, garantissant la stabilité et la continuité de service.",
          "keyWords": ["rollback", "DevOps", "restauration", "version précédente", "déploiement", "stabilité", "continuité"]
        },
        {
          "question": "Qu’est-ce qu’un container Docker ?",
          "textResponse": "Un container Docker est un environnement léger et isolé qui encapsule une application avec toutes ses dépendances, permettant de déployer de manière cohérente sur différents systèmes sans conflits.",
          "keyWords": ["container", "Docker", "environnement", "isolé", "application", "dépendances", "déploiement", "cohérent"]
        },
        {
          "question": "Quelle différence entre un container et une machine virtuelle ?",
          "textResponse": "Un container partage le noyau du système hôte et est plus léger et rapide, tandis qu’une machine virtuelle inclut un système d’exploitation complet, offrant une isolation complète mais avec plus de consommation de ressources.",
          "keyWords": ["container", "machine virtuelle", "isolation", "système hôte", "légèreté", "performance", "ressources"]
        },
        {
          "question": "Qu’est-ce qu’une image Docker ?",
          "textResponse": "Une image Docker est un modèle statique qui contient tout le nécessaire pour exécuter une application (code, bibliothèques, dépendances) et à partir duquel on peut créer un ou plusieurs containers.",
          "keyWords": ["image Docker", "modèle", "application", "bibliothèques", "dépendances", "containers"]
        },
        {
          "question": "Qu’est-ce qu’un Dockerfile ?",
          "textResponse": "Un Dockerfile est un fichier texte contenant une série d’instructions pour construire une image Docker, définissant l’environnement, les dépendances et les étapes nécessaires pour exécuter l’application.",
          "keyWords": ["Dockerfile", "instructions", "image Docker", "environnement", "dépendances", "application"]
        },
        {
          "question": "Comment démarrer un container Docker ?",
          "textResponse": "Pour démarrer un container Docker, on utilise la commande `docker run` en spécifiant l’image, les options d’exécution et les ports si nécessaire, créant ainsi un environnement isolé pour l’application.",
          "keyWords": ["démarrer", "container", "Docker", "docker run", "image", "options", "ports", "environnement isolé"]
        },
        {
          "question": "Qu’est-ce que Kubernetes ?",
          "textResponse": "Kubernetes est une plateforme open-source pour l’orchestration et la gestion de containers à grande échelle, permettant le déploiement automatisé, la mise à l’échelle et la gestion de l’état des applications conteneurisées.",
          "keyWords": ["Kubernetes", "orchestration", "containers", "déploiement automatisé", "mise à l’échelle", "gestion d’état", "applications"]
        },
        {
          "question": "Quelle est la différence entre Kubernetes et Docker Swarm ?",
          "textResponse": "Kubernetes est une plateforme d'orchestration de containers plus complète, offrant la gestion automatique des pods, le scaling, le load balancing et la surveillance, tandis que Docker Swarm est plus simple, intégré à Docker et se concentre sur le clustering et la gestion basique des containers.",
          "keyWords": ["Kubernetes", "Docker Swarm", "orchestration", "containers", "pods", "scaling", "load balancing", "monitoring", "clustering"]
        },
        {
          "question": "Qu’est-ce qu’un Pod dans Kubernetes ?",
          "textResponse": "Un Pod est la plus petite unité déployable dans Kubernetes, regroupant un ou plusieurs containers partageant le même réseau et le même stockage, permettant de gérer les applications de manière cohérente.",
          "keyWords": ["Pod", "Kubernetes", "unité déployable", "containers", "réseau", "stockage", "applications"]
        },
        {
          "question": "Qu’est-ce qu’un service Kubernetes ?",
          "textResponse": "Un service Kubernetes expose un ensemble de pods comme une seule entité réseau, permettant la communication stable entre composants et l'accès externe aux applications, tout en supportant le load balancing.",
          "keyWords": ["service", "Kubernetes", "pods", "réseau", "communication", "accès externe", "load balancing"]
        },
        {
          "question": "Qu’est-ce qu’un cluster Kubernetes ?",
          "textResponse": "Un cluster Kubernetes est un ensemble de nœuds (machines physiques ou virtuelles) qui exécutent des pods et services, orchestrés par un plan de contrôle (control plane) pour assurer la disponibilité, le scaling et la résilience des applications.",
          "keyWords": ["cluster", "Kubernetes", "nœuds", "pods", "services", "control plane", "scaling", "résilience", "disponibilité"]
        },
        {
          "question": "Qu’est-ce que Helm dans Kubernetes ?",
          "textResponse": "Helm est un gestionnaire de packages pour Kubernetes qui facilite le déploiement, la configuration et la mise à jour d’applications complexes à travers des charts, simplifiant la maintenance des clusters.",
          "keyWords": ["Helm", "Kubernetes", "gestionnaire de packages", "charts", "déploiement", "configuration", "maintenance", "clusters"]
        },
        {
          "question": "Qu’est-ce que Prometheus ?",
          "textResponse": "Prometheus est un système de surveillance et de stockage de métriques open-source qui collecte des données de performance des applications et de l’infrastructure, permettant d’alerter et d’analyser les comportements en temps réel.",
          "keyWords": ["Prometheus", "surveillance", "métriques", "open-source", "performance", "applications", "infrastructure", "alertes", "analyse"]
        },
        {
          "question": "Qu’est-ce que Grafana ?",
          "textResponse": "Grafana est une plateforme open-source de visualisation de données qui permet de créer des tableaux de bord dynamiques à partir de sources comme Prometheus, facilitant le suivi et l’analyse des performances des systèmes.",
          "keyWords": ["Grafana", "visualisation", "données", "tableaux de bord", "Prometheus", "performances", "monitoring", "open-source"]
        },
        {
          "question": "Quelle est la différence entre Ansible, Chef et Puppet ?",
          "textResponse": "Ansible est agentless et utilise YAML pour automatiser la configuration et le déploiement, Chef et Puppet utilisent des agents et des DSL spécifiques pour gérer la configuration des systèmes, Chef étant plus orienté Ruby et Puppet déclaratif, chacun ayant des approches différentes de l’automatisation.",
          "keyWords": ["Ansible", "Chef", "Puppet", "automatisation", "configuration", "agents", "YAML", "DSL", "Ruby", "déclaratif"]
        },
        {
          "question": "Qu’est-ce que Terraform ?",
          "textResponse": "Terraform est un outil open-source d’infrastructure as code qui permet de définir, provisionner et gérer des ressources cloud de manière déclarative, offrant la portabilité et la reproductibilité des environnements.",
          "keyWords": ["Terraform", "infrastructure as code", "open-source", "provisionnement", "cloud", "déclaratif", "portabilité", "reproductibilité"]
        },
        {
          "question": "Comment fonctionne la gestion de configuration avec Ansible ?",
          "textResponse": "Ansible gère la configuration en exécutant des playbooks YAML sur des hôtes distants via SSH, appliquant les états désirés des systèmes de manière répétable et idempotente, sans nécessiter d’agents.",
          "keyWords": ["Ansible", "gestion de configuration", "playbooks", "YAML", "hôtes distants", "SSH", "idempotent", "répétable", "agents"]
        },
        {
          "question": "Comment fonctionne la mise à l’échelle automatique (auto-scaling) dans Kubernetes ?",
          "textResponse": "L’auto-scaling dans Kubernetes ajuste automatiquement le nombre de pods en fonction de métriques comme l’utilisation CPU ou la charge réseau, via le Horizontal Pod Autoscaler (HPA) ou le Vertical Pod Autoscaler (VPA), garantissant la disponibilité et l’efficacité des applications.",
          "keyWords": ["auto-scaling", "Kubernetes", "pods", "Horizontal Pod Autoscaler", "Vertical Pod Autoscaler", "CPU", "réseau", "disponibilité", "efficacité"]
        },
        {
          "question": "Qu’est-ce que le load balancing dans Kubernetes ?",
          "textResponse": "Le load balancing dans Kubernetes distribue le trafic réseau de manière uniforme entre plusieurs pods, garantissant la performance, la disponibilité et la résilience des applications déployées.",
          "keyWords": ["load balancing", "Kubernetes", "trafic réseau", "pods", "performance", "disponibilité", "résilience"]
        },
        {
          "question": "Expliquez les probes (liveness et readiness) dans Kubernetes.",
          "textResponse": "Les probes dans Kubernetes sont des contrôles de santé des pods : la liveness probe vérifie si un pod fonctionne encore, et la readiness probe indique si un pod est prêt à recevoir du trafic, assurant la stabilité et la disponibilité des services.",
          "keyWords": ["probes", "Kubernetes", "liveness", "readiness", "pods", "contrôle santé", "stabilité", "disponibilité", "services"]
        },
        {
          "question": "Expliquez le rollback dans un déploiement blue-green.",
          "textResponse": "Le rollback dans un déploiement blue-green consiste à revenir rapidement à l’ancienne version (blue) après une mise à jour déployée (green) si des erreurs sont détectées, minimisant l’impact sur les utilisateurs et garantissant la continuité du service.",
          "keyWords": ["rollback", "blue-green", "déploiement", "version", "mise à jour", "erreurs", "continuité", "utilisateurs"]
        },
        {
          "question": "Qu’est-ce que le déploiement canari (canary release) ?",
          "textResponse": "Le déploiement canari consiste à déployer une nouvelle version de l’application sur un petit sous-ensemble d’utilisateurs ou pods pour tester la stabilité et la performance avant un déploiement global, réduisant le risque d’incidents.",
          "keyWords": ["canary release", "déploiement", "nouvelle version", "sous-ensemble", "stabilité", "performance", "risque"]
        },
        {
          "question": "Comment gérer la sécurité dans un pipeline DevOps ?",
          "textResponse": "La sécurité dans un pipeline DevOps inclut l’intégration de tests de sécurité automatisés, le contrôle des accès, la gestion des secrets, le scan des vulnérabilités et la conformité continue pour garantir des livraisons sécurisées.",
          "keyWords": ["sécurité", "pipeline DevOps", "tests automatisés", "contrôle des accès", "secrets", "vulnérabilités", "conformité"]
        },
        {
          "question": "Qu’est-ce que la gestion des secrets ?",
          "textResponse": "La gestion des secrets consiste à stocker, distribuer et contrôler l’accès aux informations sensibles comme les mots de passe, clés API et certificats, afin de protéger les systèmes et applications.",
          "keyWords": ["gestion des secrets", "informations sensibles", "mots de passe", "clés API", "certificats", "sécurité", "applications"]
        },
        {
          "question": "Comment stocker les secrets de façon sécurisée ?",
          "textResponse": "Les secrets peuvent être stockés de manière sécurisée dans des outils spécialisés comme HashiCorp Vault, AWS Secrets Manager ou Kubernetes Secrets, avec chiffrement, contrôle d’accès strict et rotation régulière pour minimiser les risques.",
          "keyWords": ["secrets", "stockage sécurisé", "HashiCorp Vault", "AWS Secrets Manager", "Kubernetes Secrets", "chiffrement", "contrôle d’accès", "rotation"]
        }]
    },
    {
      "topic": "Spring Boot",
      "questions": [
        {
          "question": "Comment renvoyer une réponse personnalisée avec Spring Boot ?",
          "textResponse": "Une réponse personnalisée peut être renvoyée avec `ResponseEntity`, permettant de définir le corps, le code HTTP et les en-têtes de la réponse, offrant un contrôle complet sur le comportement REST.",
          "keyWords": ["réponse personnalisée", "Spring Boot", "ResponseEntity", "corps", "code HTTP", "en-têtes", "REST", "contrôle"]
        },
        {
          "question": "Que sont les Profiles et comment les utiliser ?",
          "textResponse": "Les Profiles dans Spring Boot permettent de définir différents ensembles de configurations pour différents environnements (dev, test, prod). On les active avec `spring.profiles.active` et on peut créer des fichiers `application-{profile}.properties` ou `application-{profile}.yml` pour chaque profil.",
          "keyWords": ["Profiles", "Spring Boot", "configurations", "environnements", "dev", "test", "prod", "spring.profiles.active", "application.properties", "application.yml"]
        },
        {
          "question": "Quelle est la différence entre `@PathVariable` et `@RequestParam` ?",
          "textResponse": "`@PathVariable` est utilisé pour extraire des valeurs directement depuis l’URL d’une requête REST, tandis que `@RequestParam` récupère les paramètres de requête passés dans l’URL après le signe `?`.",
          "keyWords": ["@PathVariable", "@RequestParam", "Spring Boot", "URL", "paramètres", "requête REST", "valeurs"]
        },
        {
          "question": "Qu'est-ce que `@Transactional` ?",
          "textResponse": "`@Transactional` est une annotation de Spring qui définit le contexte transactionnel pour une méthode ou une classe, garantissant que les opérations de persistance sont exécutées de manière atomique, avec commit ou rollback automatique en cas d’erreur.",
          "keyWords": ["@Transactional", "Spring", "transaction", "méthode", "classe", "persistance", "atomique", "commit", "rollback"]
        },
        {
          "question": "Quels sont les paramètres de `@Transactional` ?",
          "textResponse": "Les principaux paramètres de `@Transactional` incluent `propagation` (définit le comportement de propagation de la transaction), `isolation` (niveau d’isolation des transactions), `timeout` (durée maximale de la transaction), `readOnly` (indique si la transaction est en lecture seule) et `rollbackFor`/`noRollbackFor` (exceptions pour lesquelles rollback doit se produire ou non).",
          "keyWords": ["@Transactional", "propagation", "isolation", "timeout", "readOnly", "rollbackFor", "noRollbackFor", "transaction", "Spring"]
        }
      ]
    },
    {
      "topic": "Git",
      "questions": [
        {
          "question": "Qu'est-ce que Git ?",
          "textResponse": "Git est un système de contrôle de version distribué qui permet de suivre les changements dans le code source et de collaborer efficacement en équipe.",
          "keyWords": ["contrôle de version", "distribué", "collaboration", "code source"]
        },
        {
          "question": "Quelle est la différence entre Git et GitHub ?",
          "textResponse": "Git est l’outil de gestion de version, tandis que GitHub est une plateforme en ligne qui héberge des dépôts Git et facilite la collaboration.",
          "keyWords": ["Git", "GitHub", "dépôt", "hébergement", "collaboration"]
        },
        {
          "question": "Comment initialiser un dépôt Git ?",
          "textResponse": "On utilise la commande `git init` pour créer un nouveau dépôt Git local dans le répertoire courant.",
          "keyWords": ["git init", "nouveau dépôt", "local"]
        },
        {
          "question": "Comment cloner un dépôt Git ?",
          "textResponse": "On utilise `git clone <url>` pour copier un dépôt distant sur sa machine locale.",
          "keyWords": ["git clone", "dépôt distant", "copie locale"]
        },
        {
          "question": "Quelle commande affiche l'état actuel du dépôt ?",
          "textResponse": "`git status` montre les fichiers modifiés, ajoutés ou en attente de commit.",
          "keyWords": ["git status", "fichiers modifiés", "commit"]
        },
        {
          "question": "Comment ajouter des fichiers à l'index ?",
          "textResponse": "On utilise `git add <fichier>` pour ajouter des fichiers à la zone de staging avant un commit.",
          "keyWords": ["git add", "index", "staging", "commit"]
        },
        {
          "question": "Comment valider des changements ?",
          "textResponse": "La commande `git commit -m \"message\"` enregistre les changements ajoutés avec un message descriptif.",
          "keyWords": ["git commit", "valider", "message"]
        },
        {
          "question": "Comment afficher l'historique des commits ?",
          "textResponse": "On utilise `git log` pour voir la liste des commits avec auteur, date et message.",
          "keyWords": ["git log", "historique", "commits"]
        },
        {
          "question": "Quelle est la différence entre `git pull` et `git fetch` ?",
          "textResponse": "`git fetch` récupère les changements distants sans les fusionner, alors que `git pull` fait `fetch` + `merge` directement.",
          "keyWords": ["git fetch", "git pull", "fusion", "distant"]
        },
        {
          "question": "Comment créer une nouvelle branche ?",
          "textResponse": "On utilise `git branch <nom>` pour créer une branche, et `git checkout <nom>` pour s’y déplacer.",
          "keyWords": ["git branch", "git checkout", "branche"]
        },
        {
          "question": "Quelle est la différence entre `git merge` et `git rebase` ?",
          "textResponse": "`git merge` fusionne deux branches en conservant l’historique, tandis que `git rebase` réécrit l’historique pour l’aligner.",
          "keyWords": ["git merge", "git rebase", "fusion", "historique"]
        },
        {
          "question": "Comment supprimer une branche ?",
          "textResponse": "On utilise `git branch -d <nom>` pour supprimer une branche locale après fusion, ou `git branch -D <nom>` pour forcer.",
          "keyWords": ["git branch -d", "supprimer", "branche locale"]
        },
        {
          "question": "Comment ignorer certains fichiers dans Git ?",
          "textResponse": "On utilise un fichier `.gitignore` pour lister les fichiers et dossiers à ignorer.",
          "keyWords": [".gitignore", "ignorer", "fichiers"]
        },
        {
          "question": "Comment revenir à un commit précédent ?",
          "textResponse": "Avec `git checkout <id>` on se déplace vers un commit, ou `git reset` pour réinitialiser la branche.",
          "keyWords": ["git checkout", "git reset", "commit précédent"]
        },
        {
          "question": "Quelle est la différence entre `git reset` et `git revert` ?",
          "textResponse": "`git reset` modifie l’historique en déplaçant HEAD, tandis que `git revert` crée un nouveau commit qui annule un commit précédent.",
          "keyWords": ["git reset", "git revert", "annuler", "historique"]
        },
        {
          "question": "Comment travailler avec un dépôt distant ?",
          "textResponse": "On ajoute un dépôt distant avec `git remote add origin <url>`, puis on utilise `git push` et `git pull` pour synchroniser.",
          "keyWords": ["git remote", "git push", "git pull", "dépôt distant"]
        },
        {
          "question": "Comment résoudre un conflit de fusion ?",
          "textResponse": "Il faut éditer les fichiers marqués par Git, choisir les bonnes modifications, puis faire `git add` et `git commit`.",
          "keyWords": ["conflit", "fusion", "git add", "git commit"]
        },
        {
          "question": "Comment créer un tag ?",
          "textResponse": "On utilise `git tag <nom>` pour créer un tag léger, ou `git tag -a <nom> -m \"message\"` pour un tag annoté.",
          "keyWords": ["git tag", "annoté", "léger"]
        },
        {
          "question": "Comment voir la différence entre deux commits ?",
          "textResponse": "La commande `git diff <id1> <id2>` affiche les différences entre deux versions.",
          "keyWords": ["git diff", "commits", "différences"]
        },
        {
          "question": "Comment stasher ses modifications ?",
          "textResponse": "On utilise `git stash` pour sauvegarder temporairement ses changements non commités et retrouver un espace propre.",
          "keyWords": ["git stash", "sauvegarde temporaire", "propre"]
        },
        {
          "question": "Comment lister toutes les branches locales et distantes ?",
          "textResponse": "La commande `git branch -a` permet de voir toutes les branches locales et distantes.",
          "keyWords": ["git branch -a", "branches", "locales", "distantes"]
        },
        {
          "question": "Quelle est la différence entre HEAD et master/main ?",
          "textResponse": "HEAD est un pointeur vers le commit courant, tandis que master/main est une branche par défaut pointant sur un commit.",
          "keyWords": ["HEAD", "master", "main", "pointeur", "branche"]
        },
        {
          "question": "Comment renommer une branche ?",
          "textResponse": "On peut utiliser `git branch -m ancien_nom nouveau_nom`.",
          "keyWords": ["git branch -m", "renommer", "branche"]
        },
        {
          "question": "Comment supprimer un fichier suivi par Git sans le supprimer localement ?",
          "textResponse": "On utilise `git rm --cached <fichier>` pour retirer un fichier de l’index mais le garder localement.",
          "keyWords": ["git rm --cached", "supprimer", "index", "local"]
        },
        {
          "question": "Quelle est la différence entre `origin` et `upstream` ?",
          "textResponse": "`origin` est le dépôt distant principal cloné, tandis que `upstream` est souvent le dépôt source officiel.",
          "keyWords": ["origin", "upstream", "dépôt distant"]
        },
        {
          "question": "Comment voir les modifications d’un fichier précis ?",
          "textResponse": "On utilise `git diff <fichier>` pour afficher les changements dans un fichier donné.",
          "keyWords": ["git diff", "modifications", "fichier"]
        },
        {
          "question": "Comment rétablir un fichier modifié à sa version précédente ?",
          "textResponse": "Avec `git checkout -- <fichier>`, on remet un fichier à son état du dernier commit.",
          "keyWords": ["git checkout --", "restaurer", "fichier"]
        },
        {
          "question": "Comment travailler avec des sous-modules Git ?",
          "textResponse": "On utilise `git submodule add <url>` pour ajouter un dépôt comme sous-module dans un projet.",
          "keyWords": ["git submodule", "sous-modules", "dépôt"]
        },
        {
          "question": "Comment savoir qui a modifié une ligne dans un fichier ?",
          "textResponse": "La commande `git blame <fichier>` affiche l’auteur et le commit de chaque ligne.",
          "keyWords": ["git blame", "ligne", "auteur", "commit"]
        },
        {
          "question": "Quelle est la différence entre un commit léger et un commit signé ?",
          "textResponse": "Un commit signé utilise une clé GPG pour garantir l’identité de l’auteur.",
          "keyWords": ["commit signé", "GPG", "identité"]
        },
        {
          "question": "Comment récupérer un commit supprimé ?",
          "textResponse": "On peut utiliser `git reflog` pour retrouver un commit perdu puis `git checkout` ou `git reset`.",
          "keyWords": ["git reflog", "commit perdu", "récupérer"]
        },
        {
          "question": "Comment mettre à jour un fork depuis le dépôt original ?",
          "textResponse": "On ajoute l’upstream (`git remote add upstream <url>`) puis `git fetch upstream` et `git merge upstream/main`.",
          "keyWords": ["fork", "upstream", "mise à jour"]
        },
        {
          "question": "Quelle est la différence entre fast-forward et merge commit ?",
          "textResponse": "Un fast-forward déplace simplement le pointeur de branche, tandis qu’un merge commit crée un commit supplémentaire.",
          "keyWords": ["fast-forward", "merge commit", "fusion"]
        },
        {
          "question": "Comment voir la différence entre l’index et le dépôt ?",
          "textResponse": "Avec `git diff --cached`, on compare l’index avec le dernier commit.",
          "keyWords": ["git diff --cached", "index", "commit"]
        },
        {
          "question": "Comment mettre à jour un tag sur un dépôt distant ?",
          "textResponse": "On force le push avec `git push origin <tag> -f`.",
          "keyWords": ["git push", "tag", "forcer"]
        },
        {
          "question": "Comment créer une branche à partir d’un commit précis ?",
          "textResponse": "On utilise `git checkout -b <branche> <commit>`.",
          "keyWords": ["git checkout -b", "branche", "commit précis"]
        },
        {
          "question": "Comment configurer Git avec son nom et email ?",
          "textResponse": "Avec `git config --global user.name` et `git config --global user.email`.",
          "keyWords": ["git config", "user.name", "user.email"]
        },
        {
          "question": "Quelle est la différence entre `git fetch --all` et `git pull --all` ?",
          "textResponse": "`git fetch --all` récupère les changements de tous les remotes, `git pull --all` essaie aussi de les fusionner.",
          "keyWords": ["git fetch --all", "git pull --all", "remotes"]
        },
        {
          "question": "Comment travailler avec plusieurs remotes ?",
          "textResponse": "On peut ajouter plusieurs dépôts distants avec `git remote add <nom> <url>` et pousser/puller séparément.",
          "keyWords": ["git remote", "plusieurs remotes"]
        },
        {
          "question": "Comment afficher la configuration Git courante ?",
          "textResponse": "On utilise `git config --list`.",
          "keyWords": ["git config --list", "configuration"]
        },
        {
          "question": "Comment signer automatiquement tous les commits ?",
          "textResponse": "On configure `git config --global commit.gpgsign true`.",
          "keyWords": ["commit.gpgsign", "signer", "automatique"]
        },
        {
          "question": "Comment annuler un `git add` ?",
          "textResponse": "On utilise `git reset <fichier>` pour retirer un fichier de la zone de staging.",
          "keyWords": ["git reset", "annuler", "git add"]
        },
        {
          "question": "Quelle est la différence entre `git clean` et `git reset --hard` ?",
          "textResponse": "`git clean` supprime les fichiers non suivis, `git reset --hard` réinitialise les fichiers suivis au dernier commit.",
          "keyWords": ["git clean", "git reset --hard", "fichiers suivis", "non suivis"]
        },
        {
          "question": "Comment afficher les commits d’une seule branche ?",
          "textResponse": "On utilise `git log <branche>`.",
          "keyWords": ["git log", "branche", "commits"]
        },
        {
          "question": "Comment annuler le dernier commit mais garder les fichiers ?",
          "textResponse": "On fait `git reset --soft HEAD~1`.",
          "keyWords": ["git reset --soft", "HEAD~1", "annuler commit"]
        },
        {
          "question": "Comment forcer un push malgré des divergences ?",
          "textResponse": "On utilise `git push origin <branche> --force`.",
          "keyWords": ["git push --force", "forcer", "branche"]
        },
        {
          "question": "Quelle est la commande pour compresser l’historique Git ?",
          "textResponse": "`git gc` (garbage collection) optimise et nettoie le dépôt.",
          "keyWords": ["git gc", "compression", "optimisation"]
        }
      ]
    }
  ];

  window.addEventListener('DOMContentLoaded', () => {
    reorderKeywords(defaultData)

    renderContent(defaultData);
  });
  window.addEventListener('scroll', () => {
    const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
    const scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    const scrolled = (scrollTop / scrollHeight) * 100;

    document.getElementById('scrollPercent').textContent = Math.round(scrolled) + '%';
  });

  document.getElementById('jsonFileInput').addEventListener('change', function (event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const data = JSON.parse(e.target.result);
        renderContent(data);
      } catch (err) {
        alert('Invalid JSON file!');
      }
    };
    reader.readAsText(file);
  });

  function reorderKeywords(obj) {
    obj.forEach(topic => {
      topic.questions.forEach(q => {
        q.keyWords.sort((a, b) => {
          const idxA = q.textResponse.indexOf(a);
          const idxB = q.textResponse.indexOf(b);

          // Si un mot est absent, on lui donne un index "infini"
          const safeA = idxA === -1 ? Number.MAX_SAFE_INTEGER : idxA;
          const safeB = idxB === -1 ? Number.MAX_SAFE_INTEGER : idxB;

          return safeA - safeB;
        });
      });
    });
  }
  function renderContent(topics) {
    const content = document.getElementById('content');
    content.innerHTML = ''; // Clear previous content

    topics.forEach(topic => {
      // Create topic header
      const topicDiv = document.createElement('div');
      topicDiv.className = 'topic';
      topicDiv.textContent = topic.topic;
      content.appendChild(topicDiv);

      // Create questions
      topic.questions.forEach(q => {
        const questionDiv = document.createElement('div');
        questionDiv.className = 'question';

        const headerDiv = document.createElement('div');
        headerDiv.className = 'question-header';

        const questionText = document.createElement('span');
        questionText.textContent = q.question;

        const infoButton = document.createElement('button');
        infoButton.textContent = 'Info';
        infoButton.onclick = () => alert(q.textResponse);

        headerDiv.appendChild(questionText);
        headerDiv.appendChild(infoButton);
        questionDiv.appendChild(headerDiv);

        // Add checkboxes
        const keywordsDiv = document.createElement('div');
        keywordsDiv.className = 'keywords';
        q.keyWords.forEach(word => {
          const label = document.createElement('label');
          label.className = 'keyword';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          label.appendChild(checkbox);
          label.appendChild(document.createTextNode(word));
          keywordsDiv.appendChild(label);
          keywordsDiv.appendChild( document.createElement('br'));
        });
        questionDiv.appendChild(keywordsDiv);

        content.appendChild(questionDiv);
      });
    });
  }

</script>
</body>
</html>
